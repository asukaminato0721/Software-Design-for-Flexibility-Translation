
6 分层 在第1.1节中，我们提到了编程可以从架构实践中学习的想法。一个程序员可能从一个可执行的骨架计划（parti）开始，以帮助尝试一个想法。当parti看起来不错时，程序员可以用更多的信息来阐述它。
例如，声明的实现类型可以使高效代码的编译成为可能并抑制类型错误的发生。宣告的尺寸和单位可以被添加到防止一些错误和支持文档。谓词的断言可以帮助定位运行时发生的错误，它们可以支持自动或手动构建 "正确性 "的证明。对某些数字量和运算需要多少精度的声明可以使数字分析问题更加清晰。对替代性实现的建议可以使实现中出现有用的退化。我们可以通过携带依赖关系来追踪一个结果的来源。
但是将这些重要而强大的功能添加到程序文本中的通常方式会使程序文本变成一团乱麻。继续用建筑学的比喻，它没有把被服务的空间和服务者的空间分开。将程序的 "基本 "特征（定义其行为的代码）与 "偶然 "的特征（例如，编译器的类型信息或记录的代码）分开一直是一个重要的问题。面向方面的编程[67]是解决这个问题的一个尝试，它明确指出了 "跨领域的关注"，如日志。分层是另一种实现分离的方式。用其他数据或代码来注释任何一块数据或代码的能力是构建灵活系统的一个关键机制。值的装饰是对用于支持可扩展通用操作的标记的概括。在这里，我们引入了分层编程的概念。数据和处理数据的程序都将由多层组成，在不引入杂乱的情况下实现添加注释。
6.1 使用图层 图层让我们有能力勾勒出一个计算，然后用与计算一起处理的元数据来阐述这个计算。让我们考虑一些注释，我们认为这些注释在许多情况下可能是有价值的。例如，假设我们对使用牛顿的重力法感兴趣。
(定义 (F m1 m2 r)
(/ (* G m1 m2) (平方r)))
这是一个简单的数字计算，但我们可以对其进行阐述，以携带支持信息和单位。
我们通过查询NIST公布的最新测量结果，找到牛顿常数G。
(定义G
(layer-datum 6.67408e-11 unit-layer (unit 'meter 3 'kgogram -1 'second -2)
支持层（支持集'CODATA-2018'））。
这里我们显示了测量的数值，该测量的单位（m 3 /(kg s2)），以及数据的来源（其支持）。我们可以扩展到在另一层将测量的不确定性作为一个范围，但我们不会在这里这样做。
我们还可以从其他来源找到地球的质量，月球的质量，以及与月球的距离（半大轴）。
(定义M-Earth
(layer-datum 5.9722e24 unit-layer (unit 'kgogram 1)
支持层
(support-set 'Astronomical-Almanac-2016))
(定义M-Moon
(layer-datum 7.342e22 unit-layer (unit 'kgogram 1)
支持层
(support-set 'NASA-2006))
(定义a-Moon
(layer-datum 384399e3 unit-layer (unit 'meter 1)
支持层
(support-set 'Wieczorek-2006))
现在我们可以问一个问题："在这个距离上，地球和月球之间的引力是多少？"我们将得到答案。
(pp (F M-earth M-Moon a-moon))
#[layered-datum 1.9805035857209e20]
(base-layer 1.9805035857209e20)
(单位-层 (单位 千克 1米 1秒-2))
(支持层
(support-set Wieczorek-2006 NASA-2006 Astronomical-Almanac-2016 CODATA-2018))
结果给出了数值，该结果的单位，以及该结果所依赖的来源。
6.2 分层的含义 分层有两个部分。首先是必须能够创建一个包含多层信息的基准点。在我们的例子中，我们使用了分层数据来做到这一点。第二部分是，我们需要能够增强一个过程，使其能够（在一定程度上）独立地处理每一层。以这种方式增强的程序被称为分层程序。
我们还需要一种为图层指定名称的方法。每个层都必须有一个名字，这样才能指定基准面中的层。这个名字也被一个分层程序用来连接该层的处理和传入数据中的相应层。我们编写的例子使用变量来指代层名，如unit-layer，它被绑定到单位层的名称上。这使得用户界面不受如何指定层名的细节影响；这将证明是有用的。
层命名的另一个方面是，必须有一个区分的基础层，它代表了正在进行的底层计算。在我们使用layered- datum的例子中，基础层的值被区分为第一个参数，并且没有相关的名称。
分层数据可以由简单的数据结构建立。我们可以使用任何方便的数据结构，它可以将一个层的名称与一个值联系起来，并且允许许多这样的联系。一个特殊的名字可以用来识别基础层，使数据结构简单而统一。
构建分层程序是比较复杂的，因为大多数层的处理都需要来自基础层计算的一些信息。例如，假设我们要将两个带有支持信息的数字相乘。通常情况下，结果的支持度是参数的支持度的结合。但是，假设一个参数的底层值是零，那么结果的支持度就是零的支持度，而另一个参数的支持度就不重要了。
基础层不能依赖于任何非基础层，因为这违反了基础层的理念：它是一个独立的计算，其他层会增强它。而一个非基础层不应该依赖于另一个非基础层。一个非基础层一般不应该与另一个非基础层共享信息，因为它的行为会因为另一个层的存在或不存在而有所不同。这与我们建立加法程序的一般方法是不一致的。
因此，建立一个分层程序涉及到从基础层向非基础层共享信息和在大多数其他情况下隔离层之间的平衡。我们将在接下来的章节中解决这个问题，因为我们将探索实现分层的细节。
6.2.1 分层数据 分层数据项是一个带有关于该值的额外信息注释的基本值。注释是层名和其值的关联。例如，数字2可能是许多数据项的基础值：如果我们在处理土豆，在一袋2磅的土豆上可能有一个2美元的价格标签。数字2的每个实例都必须是一个不同的数据项，单位层有不同的值（美元或磅）。还可能有其他层：2美元的价格可能有信息说它是如何从支付给农民的价格以及运输和加工的成本中得出的。
为了解决这个问题，我们引入了分层数据集。分层数据集被表示为一个包含层和它们的值的关联的捆绑物。因此，一个2磅的土豆数量和一个2美元的土豆价格将是单独的分层数据项。
(定义 (make-layered-datum base-value alist)
(如果 (null? alist)
基准值
(让((alist
(cons (cons base-layer base-value)
(alist))
(define (has-layer? layer)
(和(assv layer alist) #t))
(定义 (get-layer-value layer)
(cdr (assv layer alist))
(定义(注释-层))
(map car (cdr alist)))
(bundle layered-datum? has-layer? get-layer-value annotation-layers)))))
层和它们的值之间的关联被表示为一个关联列表，或alist--一个键值对的列表。
为了方便起见，我们提供了layered-datum，它以属性列表的形式接收其层参数（交替使用层和值，如第300页的例子），并以相应的alist调用make-layered-datum。
(定义 (layered-datum base-value . plist)
(make-layered-datum base-value (plist->alist plist)))
这种设计提供了极大的灵活性。可能会有许多不同种类的分层数据，对于每一个分层数据，都没有对任何特定的层或层数的先验承诺。唯一的共同特征是，每个分层数据都有一个显著的层，即底层，它包含所有其他层的值都是对其进行注释的对象。
每一层都由一个体现该层具体情况的捆绑物来代表。最简单的是基础层。
(define base-layer
(让()
(定义 (get-name) 'base)
(define (has-value? object) #t)
(定义 (get-value object)
(if (layered-datum? object)
(object 'get-layer-value base-layer)
对象))
(bundle layer? get-name has-value? get-value))
这显示了一个层的主要操作：获取值操作，如果存在的话，获取层的值，或者返回一个默认值。在基础层的情况下，默认值是对象本身。
注释层有更多的复杂性。除了上述内容外，它们还管理着一组命名的程序，这些程序将在我们研究分层程序时进行探讨。make- annotation-layer程序提供了所有注释层所使用的通用基础设施；它调用它的构造参数来提供层的特定部分。
(定义 (make-annotation-layer name constructor)
(定义 (get-name) name)
(定义 (has-value? object)
(和(分层数据)对象)
(object 'has-layer? layer)))
(定义 (get-value object)
(if (has-value? object)
(object 'get-layer-value layer)
(layer 'get-default-value)))
(定义层
(构造函数 get-name has-value? get-value))
层）。
我们使用make-annotation-layer来构建单元层。
(定义单位层
(make-annotation-layer 'unit
(lambda (get-name has-value? get-value)
(定义 (get-default-value)
单位：无)
(定义 (get-procedure name arity)
见第308页的定义）。
(bundle layer? get-name has-value? get-value get-default-value get-procedure)))))
这个实现显示了该层结构的其余部分：默认值的提供者，以及实现该层对分层过程支持的过程get-procedure，我们将在下一节（第308页）研究这个问题。
作为一种常见使用情况的便利，layer-accessor创建了一个访问程序，相当于调用一个层的get-value委托。
(定义 (layer-accessor layer)
(lambda (object)
(layer 'get-value object))
(define base-layer-value
(层-附件-底层))
6.2.2 分层程序 程序也是可以分层的数据。分层过程类似于通用过程，在通用过程中，有针对不同参数类型的处理程序。而分层过程为传入数据中的不同层提供实现，并处理所有的层，以产生分层的结果。1 例如，当结合数字层和单位层时，过程可以使用数字层处理参数中的数字部分，同时使用单位层处理参数中的单位部分。
在第6.1节所示的数字例子中，牛顿力的代码F代表了parti，即要进行的计算的基本计划。它对数字进行操作；各单元对数字进行注释。实现算术运算符（如乘法）的分层通用程序有一个基础组件，对基础层中的数字进行操作，它们还有其他组件，每一层都有一个，可能对数字基础层进行注释。单位层是一个注释层，它给出了更多关于数据和计算的信息，但对计算来说并不是必不可少的。
在一个分层系统中，基础层必须能够在不参考其他层的情况下进行计算。但是注释层可能需要访问基础层中的值。如果一个参数的注释层缺失，程序的注释层可以使用默认值或者干脆不运行。在任何情况下，基础层总是运行。
为了构造一个分层过程，我们需要一个独特的名字和算术，以及一个用于实现基础计算的基数过程。
(定义 (make-layered-procedure name arity base-procedure)
(让* ((metadata
(make-layered-metadata name arity base-procedure))
(程序
(分层-程序-调度器元数据))
(set-layered-procedure-metadata! procedure metadata)
程序))
关于分层程序的信息被保存在该程序的元数据中。元数据还管理着基础层和注释层的处理程序。
分层过程的元数据是作为一个包来实现的。它是用分层过程的名称、它的算数和基础过程（基础层的处理程序）创建的。
元数据提供了对这些的访问。它还提供了set- handler！用于为一个注释层分配一个处理程序，以及get- handler用于检索一个注释层的处理程序。
每个注解层，例如单元层，都提供了get-procedure，当给定一个过程名和节数时，会返回该层的该过程名和节数的适当处理程序。由分层元数据提供的get-handler首先检查它是否有针对该层的处理程序。如果有，它就返回该处理程序；否则它就返回该层的get-程序的结果。
(定义 (make-layered-metadata name arity base-procedure)
(让((handlers (make-weak-alist-store eqv?)))
(定义 (get-name) name) (定义 (get-arity) arity)
(定义 (get-base-procedure) base-procedure)
(define has?(handlers 'has?))
(定义get (handlers 'get))
(define set-handler!(handlers 'put!))
(定义 (get-handler layer)
(如果(有? 层)
(获取图层)
(layer 'get-procedure name arity)))
(bundle layered-metadata? get-name get-arity get-base-procedure get-handler set-handler! ))
应用分层程序的实际工作是由分层程序-调度器完成的。调度器必须能够访问并应用基础程序和与分层程序相关的注释层程序。所有这些信息都是由元数据提供的。
(定义 (分层-程序-调度器元数据)
(让((base-procedure (metadata 'get-base-procedure)))
(定义 (the-layered-procedure . args)
(让((基-值
(应用基础程序
(map base-layer-value args))
(注释-层
(apply lset-union eqv?
(map (lambda (arg)
(if (layered-datum? arg)
(arg 'annotation-layers)
'()))
args))))
(make-layered-datum base-value)
(filter-map; drops #f values)
(lambda (layer)
(让((handler (metadata 'get-handler layer)))
(和处理程序
(弊端层
(应用处理程序基值 args)))))
annotation-layers))))
分层程序))
当被调用时，分层过程首先在参数的基础层值上调用base-procedure以获得基础值。它还通过检查每个参数来确定哪些注释层是适用的；如果没有注释层有处理程序，那么结果只是基础层的值，因为make- layered-datum（在第303页），将返回未注释的基础值。否则，每个适用层的处理程序被调用，以产生该层的值。特定层的处理程序被赋予对计算出的基值和分层过程的参数的访问权；除了它自己的和基础层的值之外，它不需要任何其他层的值。一般来说，结果是一个分层数据，包含基值和适用的注释层处理程序的值。
为了看看这在实践中是如何工作的，我们来看看单位层的实现（在第304页）。如果分层过程的名字是一个算术运算符，单位层的get-过程处理程序（如下）通过名字查找分层的特定过程，然后用每个参数的单位来调用分层的特定过程。(expt有一个特殊的例外，它的第二个参数没有单位的装饰，它是一个数字。)对于其他程序，单位处理是未定义的，所以get-procedure返回#f来表示这一点。
(定义 (get-procedure name arity)
(if (operator? name)
(让((程序(单元-程序名称)))
(案件名称
((expt)
(lambda (base-value base power)
(程序 (get-value base)
(底层值 power-))))
(否则
(lambda (base-value . args)
(apply procedure (map get-value args)))))))
#f))
注意，由于get-procedure是unit-layer的内部过程，它可以访问从make-annotation-layer（第304页）继承的unit层get-value。当我们在第6.3.1节谈论单元实现时，我们将看到单元-过程。
让我们看一个例子。考虑一下简单的程序平方，将其参数平方化。
(定义 (square x) (* x x))
我们对我们的方形程序做了一个分层，把数字版本交给基础层。
(定义分层方形
(make-layered-procedure 'square 1 square))
这个分层压扁程序的行为与基本版本相同。
(分层-方形16 4)
(分层-方形'm)
(* m m)
然而，如果我们提供一个带有单位层的参数，基础层和单位层都将被单独处理，并在输出中合并。
(pp (分层-方形
(layer-datum 'm unit-layer (unit 'kilogram 1)))))
#[分层数据(* m m)]
(基础层 (* m m))
(单位-层(单位公斤2))
6.3 分层算术 现在我们知道了如何制作分层程序，我们可以在算术中增加分层。我们所需要做的就是建立一个算式，为基础算式中的每个操作提供一个分层程序。我们从一个愉快的算式开始
(定义(通用符号))
(让((g (make-generic-arithmetic make-simple-dispatch-store))
(add-to-generic-arithmetic! g numeric-arithmetic)
(extend-generic-arithmetic! g function-extender)
(extend-generic-arithmetic! g symbolic-extender)
g))
并建立一个扩展器来处理该基底上的层。
(定义 generic-with-layer
(让((g (generic-symbolic)))
(extend-generic-arithmetic! g layered-extender)
g))
分层扩展器要做一些工作。它做了一个分层扩展算术，对分层数据进行操作。分层扩展算术的领域谓词是分层-数据？
分层运算的基本谓词只是底层算术的域谓词，还有一个额外的规定，即它必须拒绝分层数据项。2 常数是基本常数，对于每个算术运算符，如果有任何参数是分层的，运算就是一个分层过程，基本过程从底层算术继承。
(定义 (layered-extender base-arith)
(让((base-pred
(conjoin (arithmetic-domain-predicate base-arith)
(supplement layered-datum?)))))
(make-arithmetic (list 'layerered
(算术名称base-arith))
层次化的数据？
(list base-arith)
(lambda (name base-value)
基准值)
(lambda (operator base-operation)
(make-operation operator)
(any-arg (operator-arity operator)
分层数据？ 基准预测)
(make-layered-procedure operator
(操作者-团结操作者)
(操作程序 base-operation))))))))
几乎所有这些都是模板，包括不使用常量对象和要求操作的至少一个参数是分层的。唯一有趣的部分是最后三行，在这三行中，基本算术的操作过程被包裹在一个分层过程中。操作符被用作分层过程的名称，这样每一层都可以在该操作需要时提供特殊处理。
6.3.1 单位算术 我们需要一个单位算术，用于算术上的单位注释层。一个单位规范有命名的基本单位，以及每个基本单位的指数。3 在单位算术中，单位规格的乘积是一个新的单位规格，其中每个基本单位的指数是参数中相应基本单位的指数之和。
(单位:* (单位'公斤1'米1'秒-1)
(单位'秒-1))
(单位：千克1米1秒-2)
这里我们假设基本单位只是用符号来命名，如千克.
单位规格的表示 为了便于创建单位规格，我们在外部将其表示为基本单位名称和指数的属性列表（有交替的键和值）。
但是在内部，将一个单元规范表示为一个标记的alist是很方便的；所以我们必须使用plist->alist将原始属性列表转换为alist表示。我们保持alist按基本单元名称排序。在这个转换中，我们做了一些错误检查。
给单位的参数列表必须是属性列表的形式。与每个基本单位名称相关的指数必须是一个精确的有理数（通常是一个整数）。如果一个命名的基本单元被重复了，那就是一个错误。如果基本单元名称不是一个符号，按基本单元名称排序将提示错误。
(定义 (unit . plist)
(保证plist? plist '单元)
(让((alist
(sort (plist->alist plist)
(lambda (p1 p2)
(符号<?(car p1) (car p2))))))
(如果 (sorted-alist-repeated-key? alist)
(错误 "基本单位重复" plist))
(for-each (lambda (p)
(保证精确有理？(cdr p))
列表)
(alist->unit alist)))
(定义 (sorted-alist-repeated-key? alist)
(和(pair? alist)
(pair?(cdr alist))
(or (eq?(caar alist) (caadr alist))
(sorted-alist-repeated-key?(cdr alist)))))
过程alist->unit只是给alist附加一个唯一的标签；而unit->alist则是从一个单元规范中提取alist。
(定义 (alist->unit alist)
(cons %unit-tag alist))
(定义 (unit->alist unit)
(保证 unit? unit 'unit->alist)
(cdr单位))
在这里，%unit-tag的值只是一个唯一的符号，我们用它来作为单元规格书alist的标题。为了使打印出来的单元规范看起来像我们给单元做单元规范的属性列表，我们安排Scheme打印机以属性列表形式打印单元规范。这个神奇的安排
(这里没有显示）是由列表头部的单元标签符号触发的。
如果谓词unit? 的参数是一个合法的单位规格，则为真。
(define (unit? object)
(和(对？对象)
(eq?(car object）%unit-tag)
(list?(cdr object))
(every (lambda (elt)
(和(对? elt)
(符号?(car elt))
(exact-rational?(cdr elt))))
(cdr object))))
单位算术运算 我们将单位算术运算构建为运算符名称和实现所需行为的运算之间的映射。
纯数，如π，是无单位的。当一个有单位的量与一个无单位的数相乘时，其结果是有单位的量的单位。因此，单位运算需要一个无单位数的乘法特性--这就是单位：无。简单运算过程结合了运算符、适用性测试和实现运算的过程。
(定义 (单位-算术)
(make-arithmetic 'unit unit?'()
(lambda (name))
(如果 (eq? name 'multiplicative-identity)
单位:无
(default-object))
(lambda (operator))
(简单操作的操作员单元？
(单位-程序操作员)))))
我们调用unit-procedure来为每个操作者获得适当的程序。
(定义(单元程序操作者))
(案例操作者
((*)单位：*)
((/) 单位:/)
((余下的)单位:余下的)
((expt) unit:expt)
((invert) unit:invert)
((平方) 单位:平方)
((sqrt) 单位:sqrt)
((atan) 单位:atan)
((abs ceiling floor negate round truncate)
unit:simple-unary-operation)
((+-最大最小)
unit:simple-binary-operation)
((acos asin cos exp log sin tan)
单位:无单位-操作)
((angle imag-part magnitude make-polar make-rectangular real-part)
;；第一近似值：单位：无单位-操作)
(否则
(如果(eq?'boolean (operator-codomain operator))
(if (n:= 1 (operator-arity operator))
unit:unary-comparison unit:binary-comparison)
unit:unitless-operation))))
对于上述每种情况，我们必须提供适当的操作。
例如，要将两个单位的数量相乘，我们必须加上相应的指数，并删除任何指数为零的基本单位。
(定义 (unit:* u1 u2)
(alist->unit
(let loop ((u1 (unit->alist u1)) (u2 (unit->alist u2))
(if (and (pair? u1) (pair? u2))
(让((因素1(车u1))(因素2(车u2)))
(如果 (eq?(car factor1) (car factor2)) ; 同一单位
(let ((n (n:+ (cdr factor1) (cdr factor2)))))
(如果(n:=0 n)
(循环 (cdr u1) (cdr u2))
(cons (cons (car factor1) n)
(循环 (cdr u1) (cdr u2))))))
(如果(符号<?(car factor1) (car factor2))
(cons factor1 (loop (cdr u1) u2))
(cons factor2 (loop u1 (cdr u2)))))))
(if (pair? u1) u1 u2)))))
一些运算符，如余数、expt、反转、平方、sqrt和atan，需要特别处理。其余的运算符可以归入几个简单的类别。简单的单项运算，如否定，只是将其参数的单位传播到其结果。
(定义 (unit:simple-unary-operation u)
u)
但有些，如加法的实施，检查他们是不是 "把苹果和橘子结合起来"："
(定义 (unit:simple-binary-operation u1 u2)
(如果 (not (unit=? u1 u2))
(错误 "不兼容的单位:" u1 u2))
u1)
练习6.1:派生单位 虽然上面给出的单位计算是正确的，也是合理完整的，但它不是很好用。例如，动能的单位规格（如第316页所示）是。
(单位：千克1米2秒-2)
这在国际单位制（SI）方面是正确的
基本单位{公斤、米、秒}，但如果用焦耳，即SI派生的能量单位来表示，会好得多。
(单位：焦耳1)
SI基本单位的完整系统是{千克、米、秒、安培、开尔文、摩尔、坎德拉}，还有一套经批准的衍生单位。例如：牛顿=公斤-米-秒-2焦耳=牛顿-米库仑=安培-秒瓦特=焦耳-秒-1伏特=瓦特-安培-1欧姆=伏特-安培-1西门子=欧姆-1法拉=库仑-伏特-1韦伯=伏特-秒亨利=韦伯-安培-1赫兹=秒-1特斯拉=韦伯-米-2帕斯卡=牛顿-米-2 A．做一个程序，用SI基本单位描述一个单位，如果可能，用派生单位做一个更简单的描述。
b.用派生单位来表达一个单位的描述并不是唯一的--可能有很多这样的等价描述。这类似于代数简化的问题，但 "更简单 "的标准并不明显。
做一个你喜欢的好版本，并解释你为什么喜欢它。
c.能够使用单位的标准缩写和乘数是件好事。例如，1 mA是写0.001 A或1/1000安培的好方法。设计并实现一个简单的可扩展系统，允许在输入和输出中使用这些符号化的便利。但请记住，"句法糖会导致分号的癌症"。6.4 用依赖关系注释数值 程序员可能想在程序的某些部分部署的一种注释是对依赖关系的跟踪。每一块数据（或程序）都来自某处。要么它作为一个前提进入计算，可以用它的外部出处来标注，要么它是通过组合其他数据而产生的。我们可以为系统的原始操作提供注释层，在处理有理由的数据时，可以用适当的理由对结果进行注释。
理由可以有不同层次的细节。最简单的一种理由只是对新数据有贡献的那些前提的集合。像加法这样的程序可以形成一个总和，其理由只是所提供的加数的理由的前提的结合。乘法也是类似的，但是一个零的乘方足以迫使乘积为零，所以其他因素的理由不需要包括在零乘积的理由中。
这种简单的理由可以被计算和携带，而不需要更多的恒定开销，但它们在调试复杂的过程和对计算结果的归因或责备方面是非常宝贵的。就这一点就足以支持依赖性导向的回溯。(见第7.5节）。
外部提供的数据可以用一个确定其来源的前提来注释。更一般地说，任何数据值都可以用一组前提来注释，这被称为它的支持集。注释一个数据的支持集通常被称为其支持。当一个支持度识别程序被应用于多个参数时，它必须结合各参数的支持度集来表示结果的支持度。
管理支持集是我们分层数据机制的一个直接应用。我们为我们的通用算术添加了一个支持层来处理支持集。它与其他层共存，如单位层。所以这是一个附加的功能。
在第309页，我们建立了一个支持分层数据和程序的算式。
(定义 generic-with-layer
(让((g (generic-symbolic)))
(extend-generic-arithmetic! g layered-extender)
g))
(Install-arithmetic! generic-with-layer)
我们不需要指定 layered-extender 支持哪些层，因为它自动使用每个分层过程参数中的层。因此，如果，比如说，+被调用的参数有单位，那么结果也会有单位。但是如果参数中没有一个有单位，那么结果也没有，单位加法过程就不会被调用。同样地，如果参数有支持，那么结果也会有支持。但是如果参数没有支持，结果也不会有支持，支持加法程序也不会被调用。
例如，我们可以定义一个质量为m、速度为v的粒子的动能。
(定义 (KE m v)
(* 1/2 m (平方 v))
现在我们可以看到对一些论据进行动能评估的结果。
(pp (KE (layer-datum 'm unit-layer (unit 'kgogram 1)
支持层（支持集'cph'））。
(layer-datum 'v unit-layer (unit 'meter 1 'second -1)
支持层 (support-set 'gjs))))
#[分层数据(* (* 1/2 m) (平方 v))]
(底层 (* (* 1/2 m) (平方 v)))
(单位-层 (单位 千克 1米 2秒-2))
(support-layer (support-set gjs cph))
我们为每个参数提供单位层和支持层的注释。对于支持层，我们给出了一组前提
(支持集)。在这里，每个参数都由一个前提支持，分别是cph和gjs。该值是一个有三层的对象：基础通用算术层值是适当的代数表达式；单位是正确的；支持集是促成该值的命名前提集。
在这里，我们接受了KE的定义，但没有为该程序提供明确的支持。更一般地说，我们可能想增加这种支持。例如，我们可能想说KE是由一个前提KineticEnergy-classical支持的。然后，如果我们发现某个复杂的计算结果似乎是错误的，我们可以找出哪些程序促成了错误的答案，以及所使用的数字或符号输入值。我们将在练习6.2中攻击这个问题。
并非所有出现在计算的论据中的前提都需要出现在结果中。例如，如果对一个产品有贡献的一个因素是零，这就足以说明产品是零，与任何其他有限的因素无关。这可以通过提供一个零质量来说明。
(pp (KE (layered-datum 0 unit-layer (unit 'kgogram 1) support- layer)
(support-set 'jems))
(layer-datum 'v unit-layer (unit 'meter 1 'second -1)
支持层 (support-set 'gjs))))
#[分层日期为0]
(基础层0)
(单位-层 (单位 千克 1米 2秒-2))
(support-layer (support-set jems))
在这里，对结果的数值为零的支持只是为质量的零值提供的支持。
6.4.1 支持层 现在我们来看看支持层是如何实现的。它与单元层有些不同，因为单元可以在不参考基础层的情况下进行组合，而支持层则需要查看基础层的一些操作。
支持层比单位层要简单一些，因为除了三个算术运算符之外，所有的运算符都使用默认值：结果的支持集是参数的支持集的联合。
(定义支持层
(make-annotation-layer 'support
(lambda (get-name has-value? get-value)
(定义 (get-default-value)
(support-set))
(定义 (get-procedure name arity)
(案件名称
((*)支持：*)
((/)支持：/)
((atan2) 支持:atan2)
(else support:default-procedure)))
(bundle layer? get-name has-value? get-value get-default-value get-procedure)))))
(定义支持层--价值
(层-存取器支持-层))
(定义 (support:default-procedure base-value . args)
(apply support-set-union (map support-layer-value args))
乘法是第一个有趣的例子。支持层需要查看基础算术参数的值来确定支持度的计算。如果任何一个参数是零，那么对结果的支持就只有零参数的支持。
(定义 (support:* base-value arg1 arg2)
(让((v1(基层值arg1)))
(v2 (基础层值arg2))
(s1 (support-layer-value arg1))
(s2 (support-layer-value arg2))
(if (exact-zero? v1)
(if (exact-zero? v2)
(如果 (< (length (support-set-elements s1))
(length (support-set-elements s2))
s1 s2)
 ;任意的s1)
(if (exact-zero? v2)
s2
(support-set-union s1 s2)))))
除法（和正切，未显示）也要检查底层来处理零参数。如果除数为零，这就足以支持商为零的结果。除数永远不会是零，因为底层的计算会发出错误信号，这段代码不会被运行。
(define (support:/ base-value arg1 arg2)
(让((v1(基层值arg1)))
(s1 (support-layer-value arg1))
(s2 (support-layer-value arg2))
(if (exact-zero? v1)
s1
(support-set-union s1 s2))))
这些对*和/的优化只有在我们能够证明一个参数确实是零，而不是一个未简化的符号表达式时才有意义。(但如果一个表达式简化为精确的零，我们就可以利用这一事实！）。
(定义 (exact-zero? x)
(and (n:number? x) (exact? x) (n:zero? x))
支持集抽象被实现为一个列表，从符号支持集开始
(定义 (%make-support-set elements)
(cons 'support-set elements))
(define (support-set? object)
(和(对？对象)
(eq?'support-set (car object))
(list?(cdr object))))
(定义 (support-set-elements support-set)
(cdr support-set))
以及一些额外的实用工具来完成抽象。
(定义 (make-support-set elements)
(如果 (null? elements)
%空支持-集
(%make-support-set (delete-duplicates elements)))))
(定义 (support-set . elements)
(如果 (null? elements)
%空支持-集
(%make-support-set (delete-duplicates elements)))))
(定义 %empty-support-set
(%make-support-set '()))
(定义 (support-set-empty? s)
(null?(support-set-elements s))
我们需要能够计算支持集的联合，并将新的元素连接到它们。由于我们选择将我们的元素放在一个列表中，我们可以使用Scheme.4中的lset库。
(定义 (support-set-union . sets)
(make-support-set
(apply lset-union eqv?
(map support-set-elements sets)))))
(定义 (support-set-adjoin set . elts)
(make-support-set
(apply lset-adjoin eqv?(support-set-elements set) elts))
练习6.2：程序性责任 基于算术的支持层是极其低级的。每一个原始的算术操作都是支持性的，对于常见的条件，没有办法绕过这些工作。需要有一种抽象化的手段。例如，假设我们有一个程序可以计算一个函数的数字定积分。积分数值的单位是积分体数值的单位与积分极限数值的单位的乘积。(上限和下限的单位必须相同！）然而，在积分过程中，将单位计算贯穿于所有详细的算术过程中并不是一个好主意。应该可以对积分器进行注释，使其结果具有正确的单位，而不要求每一个内部加法和乘法都是在分层数据上操作的分层程序。
a.使之有可能允许从原始算术程序中建立复合程序（也可能不允许）。
通过添加一个前提（如 "由乔治制造"）来修改对其结果的支持。
b.允许复合程序的执行方式是将其主体从支持层隐藏起来。因此，例如，一个受信任的库程序可以用适当的支持来注释其结果，但其主体中的操作将不会产生计算中间结果支持的开销。
c.支持层是围绕算术系统的运算符组织的。但有时区分一个运算符的具体发生情况是很有用的。例如，在处理数字精度时，说重要性的损失是由于几乎相等的数量的减法造成的，这不是很有帮助。显示出减法的具体实例会更有帮助，因为那是罪魁祸首。是否有办法在支持层中增加识别运算符实例的能力？练习6.3：偏执型编程 有时我们不确定一个库程序是否做了我们期望的事情。在这种情况下，谨慎的做法是用一个测试来 "包装 "这个库过程，以检查其结果。例如，我们可能正在使用一个程序solve，它将一组方程和一组未知数作为输入，这些未知数可能出现在方程中，产生一组满足方程的未知数的替换。我们可能想用一个包装器来包装这个求解程序，该包装器可以检查将输出代入输入方程的结果是否确实使它们成为同义反复。但我们不希望这样一个偏执的包装器出现在我们的parti中。这种东西怎么能作为一个层来实现呢？解释一下你的设计并实现它。
练习6.4:用于分层程序的集成开发环境 这个练习是一个重要的设计项目：发明和开发一个用于分层系统的集成开发环境（IDE）。
分层程序的想法，使用分层数据和分层程序，是一个非常好的想法。我们的目标是能够用有用的和可执行的元数据来注释程序--例如类型声明、断言、单元和支持--而不会使基本程序的文本变得混乱。然而，程序的文本必须与注释的文本相联系，因此，当程序的任何部分被编辑时，相关的层也会被编辑。例如，假设有必要编辑一些分层程序的基础程序。这些层可能是诸如类型声明或如何处理单元和支持集的信息。如果编辑器能在必要时向我们展示这些层以及它们与基础程序文本的联系，那就更好了。也许对基础程序文本的编辑会导致对注释层的编辑。有时这可以自动完成，但往往程序员必须编辑这些层。
a.想象一下，你希望在IDE中看到什么，以支持分层系统的开发。你希望在屏幕上看到什么？你将如何保持被编辑的部分同步？ b. Emacs是建立这样一个IDE的强大基础设施。
它支持多窗口和每窗口编辑模式。它对许多计算机语言都有句法支持，包括Scheme。有一些Emacs的子系统，比如org-mode，对文档有分层结构的味道。这可以扩展到帮助分层编程吗？勾勒出一种使用Emacs建立你的IDE的方法。
c.在Emacs的基础上建立一个小型但可扩展的原型，并试用。你遇到了什么问题？Emacs真的提供了一个好的起点吗？如果不是，为什么不是？报告你的实验。
d.如果你的原型很有前途，那就开发一个可靠的系统，并把它变成一个可加载的Emacs库，这样我们都可以使用你的伟大系统。
6.4.2 携带理由 更复杂的理由也可以记录用于制作数据的特定操作。这种注释可以用来提供解释（证明），但是它在空间上本质上是昂贵的--可能与执行的操作数量成线性关系。然而，有时附加一个详细的审计历史描述一个数据项的推导是合适的，以允许后来的一些进程为某种目的使用该推导，或者为调试而评估该推导的正确性。5 出于许多目的，如法律论证，有必要了解数据的出处：在哪里收集，如何收集，谁收集，如何授权收集，等等。
对一项证据的详细推导，给出每项贡献的出处，可能对确定它在审判中是否可被接受至关重要。
我们在第3.1节中建立的符号算术是可以做到这一点的一种方式。事实上，如果符号算术被用作数字算术的一层，那么每一个数字值都要用它的推导进行注释。符号算术的注释可能非常昂贵，因为数字运算符的应用的符号表达式包括其输入的符号表达式。
然而，由于我们只需要包括一个指向每个输入的指针，注释每个操作的空间和时间成本往往是可以接受的。6 所以，当需要提供解释，甚至暂时需要追踪一个难以捕捉的错误时，人们可以叠加这种理由。
练习6.5：论证 勾勒出为数据进行论证时涉及的问题。
请注意，一个数值的原因取决于它是由哪些数值得出的，以及这些数值的组合方式。如果一个值的原因是许多因素的一些数字加权组合，如在一个深度神经网络中，我们该怎么做？这是一个我们需要解决的研究问题，以使影响我们的系统负责任。
6.5 分层的承诺 我们只是触及了一个简单方便的数据和程序分层机制所能做到的表面。
这是一个开放的研究领域。支持这种分层的系统的发展会对未来产生巨大的影响。
敏感性分析是一个重要的功能，可以使用注释数据和分层程序来建立。例如，在力学中，如果我们有一个从某些初始条件演化出微分方程系统解决方案的系统，那么了解围绕参考轨迹的一管轨迹的变形方式往往是有价值的。这通常是通过与参考轨迹一起整合一个变分系统来实现的。
同样地，在一些分析中，可能会把围绕名义值的概率分布与计算的名义值一起携带。这可以通过用分布来注释数值，并为操作提供叠加程序来结合分布，由名义值指导，也许可以实现贝叶斯分析。
当然，要做好这一点并不容易。
一个更令人兴奋但又相关的想法是扰动编程。通过与微分方程的例子进行类比，我们是否可以对符号系统进行编程，使其围绕参考轨迹进行 "管 "的变化，从而使我们能够考虑查询的小变化？例如，考虑做一个搜索的问题。给出一组关键词，系统会施展一些魔法，得出符合关键词的文件列表。
假设我们渐渐地改变一个关键词。搜索对这个关键词有多敏感？更重要的是，是否有可能在渐进式的不同搜索中重复使用一些获得先前结果的工作？我们不知道这些问题的答案，但是如果有可能的话，我们希望能够通过一种扰动程序来捕获这些方法，作为基础程序的叠加。
依赖关系缓解了不一致性 数据上的依赖性注释给了我们一个强大的工具来组织类似人类的计算。例如，所有人类都怀有相互不一致的信念：一个聪明人可能致力于科学方法，但又对一些迷信或仪式的做法有强烈的依恋；一个人可能对所有人类生命的神圣性有强烈的信念，但也相信死刑有时是合理的。如果我们真的是逻辑学家，这种不一致将是致命的：如果我们真的同时相信命题P和非P，那么我们将不得不相信所有的命题！但不知何故，我们却能保持不一致。但是，我们却设法使不一致的信念不至于抑制所有有用的思考。我们的个人信仰体系似乎是局部一致的，因为没有明显的矛盾。如果我们观察到不一致的地方，我们不会崩溃；我们可能会感到矛盾，也可能会笑笑。
我们可以给每个命题附加一套支持性的假设，让推理以假设集为条件。然后，如果发生矛盾，一个过程可以确定不一致的假设的特定 "nogood集"。
然后系统可以 "笑"，意识到基于这些假设的任何超集的推理都是不可信的。这种笑的过程，即依赖性导向的回溯，可以用来优化一个复杂的搜索过程，使搜索能够最好地利用其错误。但是，使一个过程能够同时持有基于相互不一致的假设集的信念而不发生逻辑上的灾难是革命性的。
对数据使用的限制 数据经常受到对其使用方式的限制。这些限制可能是由法规、合同、习惯或一般的礼节决定的。其中一些限制是为了控制数据的传播，而另一些则是为了限制基于该数据的行动的后果。
数据的允许用途可由发送者进一步限制。"我是以保密方式告诉你这些信息。你不能用它来与我竞争，你也不能把它交给我的任何竞争对手。"数据也可能被接收者所限制。"我不想知道任何我可能不会告诉我配偶的事情。"尽管细节可能相当复杂，但当数据从一个人或组织传递到另一个人或组织时，对其用途的限制会发生变化，其方式通常可以被表述为代数表达式。这些表达式描述了如何从一个特定的数据项目的传输历史中计算出对其使用的限制：在每个步骤中增加或删除的抵押品。当一个数据集的部分内容与另一个数据集的部分内容相结合时，对摘录的使用方式的限制和对它们的组合方式的限制必须决定对组合的限制。这个过程的形式化就是数据目的代数[53]的描述。
数据目的代数层可以帮助建立跟踪敏感数据的分布和使用的系统，以实现审计和抑制该数据的滥用。但这种应用远远大于简单的分层问题。为了使其有效，需要有办法确保过程的安全性，以防止通过不受控制的渠道泄漏或破坏跟踪层。这里有大量的研究工作要做。
1 请注意，一个分层过程的层的实现本身可能是一个通用过程。同样地，一个通用程序的处理程序也可以是一个分层程序。
2程序conjoin和complement是谓词的组合器：conjoin产生一个新的谓词，是其参数的布尔值和，complement产生一个新的谓词，是其参数的否定值。
3注意!基本单位 "不能与我们的分层数据系统中的基础层相混淆。一个单位系统是建立在一组基本单位之上的，如公斤、米和秒。
有一些派生单位，例如牛顿，它是基本单位的组合：1 N = 1 kg - m - s-2 4如果支持集变得很大，我们可以尝试更有效地表示它们，但这里我们只处理小集。
5 在帕特里克-苏佩斯（Patrick Suppes）美丽的《逻辑学导论》[118]中，证明被写成了四列。这几栏分别是该行的标识符、该行的声明、用于从前面几行推导出该行的规则，以及支持该行的前提集。这种证明结构实际上是我们携带理由和支持集的方式的灵感来源。
6这其实是不对的。问题是，数字运算的组成可能不会产生明显的内存访问成本，但构建一个符号表达式，无论多么小，都需要访问内存。而与在CPU寄存器中进行运算的时间相比，内存访问时间是巨大的。
叹息...



