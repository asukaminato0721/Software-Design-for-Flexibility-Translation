 B 附录：Scheme 编程语言的设计不应该是将功能堆积在功能之上，而应该是消除那些使额外功能显得必要的弱点和限制。
Scheme表明，只要有非常少的表达式组成规则，对它们的组成方式没有任何限制，就足以形成一种实用、高效的编程语言，其灵活性足以支持当今使用的大多数主要编程范式。
IEEE Scheme编程语言标准[61]，第3页 这里我们对Lisp的Scheme方言做一个基本的介绍。更长的介绍见教科书《计算机程序的结构与解释》（SICP）[1]。
关于该语言更精确的解释，请参见IEEE标准[61]和《算法语言方案第七次修订报告》（R7RS）[109]。 本书中的一些程序依赖于MIT/GNU Scheme中的非标准特性；关于该系统的文档，请参见MIT/GNU Scheme参考手册[51]。另外，对于在其他地方有记载的Scheme功能，《参考手册》的索引提供了指向相应文件的指针。
B.1 Essential Scheme Scheme是一种基于表达式的简单编程语言。
一个表达式命名一个值。例如，数字3.14命名了一个熟悉的数字的近似值，而数字22/7命名了它的另一个近似值。有一些原始的表达式，如数字，我们可以直接识别，还有一些复合表达式，有几种类型。
复合表达式由圆括号划定。那些以杰出的关键词开始的表达式，比如if，被称为特殊形式。那些不属于特殊形式的表达式，被称为组合，表示程序对参数的应用。
组合 一个组合--也叫程序应用--是一个由括号限定的表达式序列。
(操作符-1 ... 操作符-n)
组合中的第一个子表达式，称为操作符，被用来命名一个过程，其余的子表达式，称为操作数，被用来命名该过程的参数。当过程应用于给定的参数时，返回的值是由组合命名的值。例如。
(+ 1 2.14)
3.14
(+ 1 (* 2 1.07))
3.14都是与数字3.14命名相同的组合。1在这些情况下，符号+和*分别命名为加和乘的程序。如果我们用一个命名与原子表达式相同的东西的表达式替换任何表达式的任何子表达式，整个表达式所命名的东西保持不变。
请注意，在Scheme中，每个小括号都是必不可少的：你不能增加额外的小括号，也不能删除任何小括号。
兰姆达表达式 就像我们用数字来命名数字一样，我们用兰姆达表达式来命名程序。2 例如，可以写成将其输入的程序平方化。
(lambda (x) (* x x))
这个表达式可以理解为"一个参数x的过程，将x乘以x"。当然，我们可以在任何需要过程的情况下使用这个表达式。比如说。
((lambda (x) (* x x)) 4)
16 lambda表达式的一般形式是
(lambda formal-parameters body)
其中formal-parameters是（通常）一个括号内的符号列表，它将是过程的形式参数的名称。当过程应用于参数时，形式参数将以参数作为其值。体是一个可以引用形式参数的表达式。过程应用的值是过程主体的值，参数被替换为形式参数。3 在上面的例子中，符号x是由（lambda (x) (* x x)）命名的过程的唯一形式参数。
这个程序适用于数字4的值，所以在正文中，(* x x)，符号x的值是4，组合((lambda (x) (* x x)) 4)的值是16。
我们在上面说 "通常 "是因为有例外情况。一些过程，例如用符号*命名的数字相乘的过程，可以接受不确定的参数数量。我们将在后面解释如何做到这一点（在第389页）。
定义 我们可以使用定义的特殊形式给任何对象起一个名字。
我们说，这个名字标识了一个变量，其值就是这个对象。
例如，如果我们把定义
(定义pi 3.141592653589793)
(定义平方 (lambda (x) (* x x)))
然后我们可以在数字或λ表达式可能出现的地方使用符号π和平方。例如，半径为5的球体表面的面积为
(* 4 pi (平方5))
314.1592653589793 程序定义可以用 "语法糖 "更方便地表达。方程可以被定义为
(定义 (square x) (* x x))
我们可以读作："要将x的平方乘以x"。在Scheme中，过程是第一类对象：它们可以作为参数传递，作为值返回，并被纳入数据结构。例如，我们可以制作一个过程来实现两个函数的组合这一数学概念：4
(define compose
(lambda (f g)
(lambda (x)
(f (g x)))))
((组成正方形sin) 2)
.826821810431806
(平方(sin 2))
.826821810431806 需要注意的是，返回过程中f和g的值，(lambda (x) (f (g x))是外部过程（lambda (f g) ...）的形式参数的值。这就是Scheme的词法范围纪律的本质。任何变量的值都是通过在词法上明显的上下文中找到它的绑定来获得的。对于系统全局定义的所有变量，都有一个隐含的上下文。(例如，+被系统全局性地绑定到加数的过程中）。
使用上面显示的方形的句法糖，我们可以更方便地写出compose的定义。
(定义 (compose f g)
(lambda (x)
(f (g x))))
在MIT/GNU Scheme中，我们可以递归地使用这个糖，来写出。
(定义((compose f g) x)
(f (g x))
有时，让一个定义成为另一个定义的局部是有利的。例如，我们可以这样定义compose。
(定义 (compose f g)
(定义 (fog x)
(f (g x))
雾）。
fog这个名字并没有在compose的定义之外被定义，所以在这种情况下并不是特别有用，但是如果内部片段被赋予了名字，较大的代码块往往更容易阅读。内部定义必须总是在程序主体中不属于定义的任何表达式之前。
条件式 条件式可以用来在几个表达式中选择产生一个值。例如，可以写一个实现绝对值函数的过程。
(定义 (abs x)
(cond ((< x 0) (- x))
((= x 0) x)
((>x 0) x) ))
条件性条件有许多子句。每个子句都有一个谓语表达式（可以是真或假）和一个结果表达式。cond表达式的值是第一个子句的结果表达式的值，其中相应的谓语表达式为真。条件表达式的一般形式是
(cond (predicate-1 consequent-1)
...
(前提条件-N后果-N))
为了方便起见，有一个特殊的关键字else可以作为条件的最后一个子句的谓词。
if的特殊形式提供了另一种方法，当只有一个二元选择时，可以做出一个条件。例如，因为只有当参数为负数时我们才要做一些特殊的事情，所以我们可以将abs定义为：。
(定义 (abs x)
(如果 (< x 0)
(- x)
x))
if表达式的一般形式是
(如果是谓语，则为备选)
如果谓词为真，if表达式的值就是结果的值，否则就是替代的值。
递归程序 鉴于条件和定义，我们可以编写递归程序。例如，为了计算第n个阶乘数，我们可以这样写。
(定义 (阶乘n)
(如果 (= n 0)
1
(* n (阶乘 (- n 1))))))
(factorial720 6)
(阶乘40)
815915283247897734345611269596115894272000000000 本地名称 一个let表达式被用来给本地环境中的对象命名。
比如说。
(定义 (f radius)
(让((面积(*4π(方形半径)))
(体积 (* 4/3 pi (cube radius)))))
(/体积面积))
(f1 3)
let表达式的一般形式是
(让((变量-1表达-1)
...
(变量-表达-N))
体）。
let表达式的值是上下文中主体表达式的值，其中变量variable-i具有表达式expression-i的值。表达式expression-i不得引用let表达式中给定值的任何变量变量-j。
let*表达式与let表达式相同，只是在let*表达式中，表达式-i可以指代前面给定值的变量-j。
let表达式的一个小变体提供了一种写循环的方便方法。我们可以写一个过程，实现计算阶乘的另一种算法，如下所示。
(定义 (阶乘n)
(让 factlp ((count 1) (answer 1))
(如果(>计数n)
答案
(factlp (+ count 1) (* count answer))))))
(factorial720 6)
这里，let后面的符号factlp被局部定义为一个过程，它的形式参数是变量count和answer。它第一次被调用时，以1和1作为参数，初始化循环。每当后来调用名为factlp的过程时，这些变量就会得到新的值，即操作数表达式（+ count 1）和（* count answer）的值。
表达这个程序的一个等效方式有一个明确定义的内部程序。
(定义 (阶乘n)
(定义 (factlp count answer)
(如果(>计数n)
答案
(factlp (+ count 1) (* count answer)))))
(factlp 1 1))
过程 factlp 是本地定义的；它只存在于 factorial 的主体中。因为 factlp 被词法包围在 factorial 的定义中，它的主体中 n 的值是 factorial 的形式参数的值。
复合数据--列表、向量和记录 数据可以被粘在一起形成复合数据结构。列表是一种数据结构，其中的元素是按顺序连接的。矢量是一种数据结构，其中的元素被打包成一个线性阵列。新的元素可以被添加到列表中，但是访问列表中的第n个元素需要与n成正比的计算时间。相比之下，向量是固定长度的，它的元素可以在恒定时间内被访问。记录与向量类似，只是它的字段是由名称而不是索引号来命名的。记录还提供了新的数据类型，可以通过类型谓词来区分，并保证与其他类型不同。
复合数据对象是由称为构造器的程序从组件中构造出来的，组件由选择器访问。
过程 list 是列表的构造函数。谓词 list? 对任何列表都是真，对所有其他类型的数据都是假。
(定义a-list (list 6 946 8 356 12 620))
列表
(6 946 8 356 12 620)
(list?#t a-list)
(list?#f 3)
这里#t和#f是布尔值true和false的打印表示。6 列表是由成对构建的。一个对是用构造函数cons生成的。对的两个组成部分的选择器是car和cdr（读作 "could-er"）。
(定义a-pair (cons 1 2))
a-对
(1 . 2)
(car1 a-pair)
(cdr2 a-pair)
列表是一个成对的链，这样，每一对的car是列表元素，每一对的cdr是下一对，除了最后一个cdr，它是一个可区分的值，称为空列表，写成（）。因此。
(car6 a-list)
(cdr a-list)
(946 8 356 12 620)
(car (cdr a-list))
946
(定义另一个列表
(cons 32 (cdr a-list)))
另一个列表
(32 946 8 356 12 620)
(car (cdr another-list))
946 列表 a-list 和 another-list 共享它们的尾巴（它们的 cdr ）。
谓词pair? 对成对的数据为真，对所有其他类型的数据为假。谓词null?只对空列表为真。
向量比列表更简单。有一个构造函数vector可以用来制造向量，还有一个选择器vector-ref用来访问向量的元素。在Scheme中，所有使用数字索引的选择器都是基于零的。
(定义a-vector
(向量37 63 49 21 88 56))
a-向量#(37 63 49 21 88 56)
(vector-ref a-vector 3)
21
(vector-ref a-vector 0)
37 向量的打印表示法与列表的打印表示法的区别在于初始括号前的字符#。
有一个谓词vector? 对向量是真，对所有其他类型的数据是假。
Scheme为列表中的元素提供了一个数字选择器，list-ref，类似于向量的选择器。
(list-ref a-list 3)
356
(list-ref a-list 0)
6 记录是比较复杂的，因为它们必须在构建之前被声明。一个简单的记录声明可能是
(定义记录类型点
(make-point x y)
点？
(x点-x)
(y点-y))
在这个声明之后，我们可以进行和使用积分。
(定义p (make-point 1 2))
(点? p)
#t
(point-x1
(点-y2 p)
p)
列表、向量和记录的元素可以是任何种类的数据，包括数字、程序、列表、向量和记录。
许多其他操作列表、向量和记录的程序可以在Scheme在线文档中找到。
不确定参数数的程序 我们所看到的程序都是用一个形式参数列表来指定的，这些参数与程序被调用的参数绑定在一起。然而，有许多过程需要一个不确定的参数数量。例如，将数字相乘的算术过程可以接受任何数量的参数。为了定义这样一个过程，我们将形式参数指定为一个单一的符号，而不是一个符号列表。然后，这个单一的符号被绑定到程序被调用的参数列表中。例如，给定一个二进制乘法器*:binary，我们可以写成
(定义 * (lambda args (accumulate *:binary 1 args))
其中积累只是
(define (accumulate proc initial lst)
(如果 (null? lst)
最初的
(proc (car lst)
(accumulate proc initial (cdr lst))))))
有时我们想让一个过程接受一些命名的参数和不确定数量的其他参数。在过程定义中，参数列表在最后一个参数名称前有一个点（称为点尾符号），表示点之前的参数将被绑定到初始参数上，而最后一个参数将被绑定到任何剩余参数的列表上。在上面的*的例子中，没有初始参数，所以args的值是一个所有参数的列表。因此，作为替代，我们可以将*定义为。
(define (* . args) (accumulate *:binary 1 args))
由-命名的程序更加有趣，因为它至少需要一个参数：当给定一个参数时，-否定它；当给定一个以上的参数时，它从第一个参数中减去其余参数。
(定义 (- x . ys)
(如果 (null? ys)
 ;只有一个说法？
(-:单数x)
(-:二进制x (积累+:二进制0 ys))))
这也可以写成
(定义-
(lambda (x . ys)
(如果 (null? ys)
(-:单数x)
(-:二进制x (积累+:二进制0 ys)))))
上面的例子中像args和ys这样的参数被称为其余参数，因为它们被绑定到其余参数上。
符号 符号是一种非常重要的原始数据类型，我们用它来制作程序和代数表达式。你可能已经注意到，Scheme程序看起来就像列表。事实上，它们就是列表。构成程序的列表中的一些元素是符号，如+和向量.8 如果我们要制作能够操作程序的程序，我们需要能够写出命名这种符号的表达式。
这是由引号机制完成的。符号 "+"的名称是表达式 "+"，一般来说，表达式的名称是表达式前面有一个单引号字符。
因此，表达式（+3 a）的名称是'（+3 a）。
我们可以通过使用谓词eq?来测试两个符号是否相同。例如，我们可以写一个程序来确定一个表达式是否是一个和。
(定义 (sum? expression)
(和(对?表达))
(eq?(car expression) '+)))
(sum?'(+ 3 a))
#t
(sum?'(* 3 a))
#f 考虑一下如果我们省去表达式中的引号会发生什么（sum?'(+ 3 a)).如果变量a的值是4，我们就会问7是否是一个和。但是我们想知道的是表达式(+ 3 a)是否是一个和。这就是我们需要引号的原因。
反引号 为了操作模式和其他形式的基于列表的语法，在同一个表达式中穿插引号和求值部分往往很有用。Lisp系统提供了一种叫做 "准引号 "的机制，使之变得简单。
就像我们使用撇号字符来表示常规引号一样，我们使用反引号字符来表示准引号。9 我们将这样的部分引号表达式指定为一个列表，其中要评估的部分以逗号字符为前缀。例如，'(a b ，(+ 20 3) d)
(a b 23 d)
反引号机制还提供了向列表表达式的 "拼接"：一个被评估的子表达式产生一个列表，然后被拼接到包围的列表中。例如，'(a b ,@(list (+ 20 3) (- 20 3)) d)
(a b 23 17 d)
请参考《计划报告》[109]，了解对准绳的更详细解释。
效果 有时我们需要在计算过程中执行一个动作，比如绘制一个点或打印一个值。10 例如，为了更详细地了解阶乘程序是如何计算其答案的，我们可以在factlp内部程序的正文中插入一条写行语句，以打印出每个迭代的计数和答案的列表。
(定义 (阶乘n)
(让 factlp ((count 1) (answer 1))
(写线(列表计数答案))
(如果(>计数n)
答案
(factlp (+ count 1) (* count answer))))))
当我们调用修改后的阶乘程序时，我们可以看到计数器被递增，答案被建立。
(阶乘(1 1)
(2 1)
(3 2)
(4 6)
(5 24)
(6 120)
(7 720)
720 6)
每个过程或let的主体，以及每个cond子句的结果，都允许使用有效果的语句。
效果语句一般没有有用的价值。在主体或子句中的最后表达式产生的是返回的值。
在这个例子中，if表达式产生的是阶乘的值。
赋值 像打印一个值或绘制一个点这样的效果是非常良性的，但也有更强大的（因此也是危险的）效果，称为赋值。赋值改变了一个变量的值或数据结构中的一个条目。几乎所有我们正在计算的东西都是一个数学函数：对于一个特定的输入，它总是产生相同的结果。然而，通过赋值，我们可以使对象在被使用时改变其行为。例如，我们可以使用set！来制作一个每次调用时都会增加一个计数的设备：11
(定义 (make-counter)
(让((count 0))
(lambda ()
(set! count (+ count 1))
数）））。
让我们做两个计数器。
(定义c1 (make-counter))
(定义c2 (make-counter))
这两个计数器有独立的本地状态。调用一个计数器会使它增加其本地状态变量count，并返回其值。
(c1)
1
(c1)
2
(c2)
1
(c1)
3
(c2)
2 对于分配给数据结构的元素，如一对、一个列表或一个向量，Scheme提供了。
(set-car! pair new-value)
(set-cdr! pair new-value)
(list-set! list index new-value)
(vector-set! vector index new-value)
一个记录可以被定义为允许对其字段进行赋值
(比较第388页。
(定义记录类型点
(make-point x y)
点？
(x point-x set-x!)
(y point-y set-y!))
(定义p (make-point 1 2))
(点-x p)
1
(点-y2 p)
(set-x! p 3)
(点-x3
(点-y2 p)
p)
一般来说，尽可能避免赋值是一个好的做法，但如果你需要的话，可以使用赋值。12 B.2 更高级的东西 Scheme 提供了许多更强大的功能，但我们不会在这里描述它们。例如，你可能想了解哈希表。一般来说，最好的资料是《关于算法语言方案的修订报告》（R7RS）。
[109]和MIT/GNU Scheme参考手册[51]。但这里有两个相当复杂的功能，你在阅读本书时可能需要参考。动态绑定 我们有时想指定完成某些计算或动作的方式--例如，指定打印数字时使用的弧度。为了做到这一点，我们使用一个叫做参数的对象。
例如，Scheme程序number->string会产生一个字符串，代表一个给定弧度的数字。
(number->string 100 2)
"1100100"
(number->string 100 16)
"64" 假设我们想在一个复杂的程序中的许多地方使用number->string，我们通过调用myprog来运行该程序，但我们希望能够控制程序运行时使用的radix。我们可以通过设置一个默认值为10的参数radix来实现这个目的。
(定义radix (make-parameter 10))
参数的值是通过调用参数而获得的，没有参数。
(小数点)
10 我们定义了一个专门的数字->字符串的版本，以代替数字->字符串。
(定义 (number->string-radix number)
(number->string number (radix)))
在(myprog)的执行中，每次对number->string-radix的调用都会产生一个十进制的字符串，因为(radix)的默认值为
是10。然而，我们可以用参数化来包装我们的程序，以改变执行方式，使用另一个小数。
(参数化((radix 2))
(myprog))
parameterize的语法与let的语法相同，但它只能用于由make-parameter创建的参数。
捆绑 MIT/GNU Scheme提供了一种简单的机制来构建具有共享状态的相关程序集合：捆绑。捆绑是一个过程，它委托给一个命名的过程集合：捆绑的第一个参数是要使用的委托的名称，其余的参数被传递给指定的委托。这类似于一些面向对象语言的工作方式，但要简单得多，而且没有类或继承。
捆绑有时被称为消息接受程序，其中消息类型是委托人名称，消息体是参数。13 这强调了捆绑支持消息传递协议，可以被认为是通信网络中的一个节点。
下面是一个简单的例子。
(定义 (make-point x y)
(定义 (get-x) x)
(定义 (get-y) y)
(定义 (set-x! new-x) (set! x new-x))
(定义 (set-y! new-y) (set! y new-y))
(bundle point? get-x get-y set-x! set-y!)
程序make-point定义了四个内部程序，它们共享状态变量x和y。bundle宏创建了一个bundle程序，这些程序是其代表。
bundle宏的第一个参数是一个谓词，它是用make-bundle-predicate创建的。被创建的捆绑包将满足这个谓词。
(define point?(make-bundle-predicate 'point))
(定义p1 (make-point 3 4))
(定义p2 (make-point-1 1))
(点? p1)
#t
(点？P2)
#t
(point?(lambda (x) x))
#f make-bundle-predicate的参数是一个符号，用于在调试时识别谓词。
如果不需要一个谓词，bundle也可以接受#f作为第一个参数。在这种情况下，就没有办法将创建的bundle程序与其他程序区分开来。
捆绑宏的其余参数是委托程序的名称：get-x、get-y、set-x！和set-y！。这些名字在宏的词法环境中被查找，以获得相应的委托程序。然后，一个捆绑程序被创建，包含了从每个名字到其委托程序的关联。
当所产生的捆绑过程被调用时，它的第一个参数是一个符号，这个符号必须是其中一个委托过程的名称。该关联被用来选择被命名的委托过程，然后以捆绑过程的其余参数作为其参数来调用该过程。
使用一个包袱比描述它更容易。
(p1 3
(p1 4
(p2 -1
(p2 1 'get-x)
'get-y)
'get-x)
'get-y)
(p1 'set-x! 5)
(p15
(p2-1 'get-x)
'get-x) 

1在例子中，我们展示了Scheme系统在输入表达式后面使用斜线字符打印的值。
2逻辑学家Alonzo Church[16]发明了λ符号，允许指定一个指定参数的匿名函数：λx[表达式在x中]。这被解读为："一个参数的那个函数，其值是通过在指定的表达式中用参数代替x而得到的"。3我们说形式参数是与参数绑定的，绑定的范围是程序的主体。
4这些例子是缩进的，以帮助提高可读性。Scheme并不关心额外的留白，所以我们可以随心所欲地添加，以使事情更容易阅读。
5 一个谓词是一个返回真或假的过程。根据Scheme文化的惯例，我们通常给谓词起一个以问号(?)结尾的名字，除了基本的算术比较谓词：=, <, > , <=, and >= 。 这只是一个风格上的惯例。对Scheme来说，问号只是一个普通的字符。
6条件表达式（if和cond）将任何没有明确#f的谓词值视为真，这很方便，但对某些人来说却很恼火。
7这些名字是历史的意外。它们代表了IBM 704计算机的 "寄存器地址部分的内容 "和 "寄存器递减部分的内容"，该计算机在20世纪50年代末被用于Lisp的首次实现。Scheme是Lisp的一种方言。
8 一个符号可以有任何数量的字符。一个符号通常不能包含空白或分隔符，如括号、大括号、引号、逗号或#；但有一些特殊的符号，允许在符号的名称中包含任何字符。
9在美式键盘上，反引号字符"'"是将倾斜字符"∼"作为大写字符的那个键上的小写字符。
10 这是计算机科学的行话。效果是指对某一事物的改变。例如，write-line通过向显示屏打印东西来改变显示效果。
11 这是另一个文化惯例，我们在有 "副作用 "的程序名称后面加上一个感叹号（！）。
这提醒读者，改变效果的顺序可能会改变程序的运行结果。
12 没有赋值的编程学科被称为函数式编程。功能性程序通常比指令性程序更容易理解，而且错误更少。
13 这个术语可以追溯到ACTOR框架[58]和Smalltalk编程语言[46]。

