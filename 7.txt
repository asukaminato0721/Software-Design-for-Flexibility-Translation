7 传播 几十年的编程经验已经对我们的集体想象力造成了伤害。我们来自一个稀缺的文化，在那里，计算和内存都很昂贵，而且并发性很难安排和控制。这已不再是事实。但是我们的语言、我们的算法和我们的架构思想是基于这些假设的。我们的语言基本上是顺序的和定向的，甚至函数式语言也假定计算是围绕着通过表达式树向上渗透的值来组织的。
多方向的约束在函数式语言中很难表达。
摆脱冯-诺依曼的束缚 计算的传播者模型[99]提供了一条摆脱束缚的途径。传播者模型是建立在这样的理念之上的：基本的计算元素是传播者，即通过共享单元相互连接的自主的独立机器，它们通过这些单元进行通信。每个传播者机器不断检查它所连接的单元，并根据它可以从其他单元获得的信息进行计算，向一些单元添加信息。
细胞积累信息，传播者产生信息。
由于传播器的基础结构是基于数据通过相互连接的独立机器的传播，传播器的结构最好用接线图而不是表达树来表达。在这样一个系统中，部分结果是有用的，尽管它们并不完整。例如，计算平方根的通常方法是使用Heron的方法进行连续的细化。在传统的编程中，平方根的计算结果不能用于后续的计算，直到达到要求的误差容限。相比之下，在一个执行相同功能的模拟电路中，部分结果可以被接下来的阶段作为其计算的第一近似值使用。这不是一个模拟/数字问题--它是组织问题。在一个传播者机制中，数字过程的部分结果可以在不等待最终结果的情况下被使用。
填充细节 这为构建强大的系统提供了一个自然的计算结构，可以填充细节。这种结构是加法的：只要在网络中加入新的部分，无论是简单的传播者还是整个子网络，就可以包括贡献信息的新方法。例如，如果一个不确定的量被表示为一个范围，那么一个计算上限的新方法可以被包括进来，而不会干扰网络的任何其他部分。
填充细节在我们使用信息的所有方式中都起着重要作用。例如，考虑到Kanizsa的三角形（图7.1）。
鉴于一些零碎的证据，我们看到一个白色的三角形
(在白色背景上！）不存在的（而且通常被描述为比背景更亮）。我们已经填补了一个隐含数字的缺失细节。当我们听到讲话时，我们从观察到的上下文中，利用语音学、形态学、句法学和语义学的规律性，填入细节。一个专业的电路设计师在看到部分原理图时，会填入一些细节，从而形成一个合理的机制。这种对细节的填充并不是连续的；只要能从周围的线索中进行局部的推理，它就会适时地发生。演绎可能是复合的，因此，如果一个部分被填入，它就会形成一个新的线索，用于继续完成过程。
图7.1 卡尼兹萨的三角形是完成性幻觉的一个典型例子。白色的三角形并不存在!依赖关系和回溯 利用分层，我们以一种自然而有效的方式将依赖关系纳入传播者的基础设施。这使得系统可以跟踪并保存每个值的出处信息。出处可以用来提供一个连贯的解释，说明一个值是如何得出的，并列出来源和组合源材料的规则。当我们有多个来源，每个来源都提供关于一个值的部分信息时，这一点尤其重要。依赖性跟踪也为调试提供了一个基础（也可能是自省式的自我调试）。
除了基础信念之外，假设也可以由伏尔机引入，伏尔机提供了由前提支持的替代值，这些替代值可以毫无痛苦地被舍弃掉。与基于表达式语言（如Lisp）的系统不同，表达式结构没有产生虚假的控制流来污染我们的依赖关系，并在回溯时强迫对已经计算过的值进行昂贵的重新计算。
退化、冗余和并行 传播者模型包含了支持冗余（实际上是退化）子系统集成的机制，这样就可以用多种不同的方式解决一个问题。多重冗余设计可以有效地对抗攻击：如果没有一个可以被颠覆的执行线程，那么使其中一个路径失效或延迟的攻击就不会阻碍计算，因为可以用另一个路径替代。冗余和退化的并行计算有助于完整性和弹性：沿着不同路径进行的计算可以被检查以保证完整性。由于跨线程的不变量，颠覆并行计算的工作会增加。
传播者模型本质上是并发的、分布式的、可扩展的，具有很强的隔离性和并行计算的内在假设。多个独立的传播者正在计算和贡献共享单元中的信息，在那里信息被合并，矛盾被注意并采取行动。
7.1 一个例子。恒星的距离 考虑天文学中的一个问题，估算恒星的距离。这是很困难的，因为距离是巨大的。即使是最接近的恒星，我们也可以使用视差测量，以地球轨道的半径为基准，恒星位置的角度变化是一角秒的一小部分。
事实上，恒星距离的单位是准星，它是基于地球轨道直径的一个三角形的高度，其中顶点角度为2角秒。视差是通过观察地球每年围绕太阳旋转时恒星在背景中的位置变化来测量的。(见图7.2）。
图7.2 在地球绕太阳轨道的半大轴上竖起的三角形与远方恒星的角度θ称为恒星的视差。请注意，A/d = tan(θ)。如果θ=1角秒，那么距离d被定义为1准秒。半大轴A的长度为1天文单位（AU）=149597870700米。
我们定义了一个传播器，将一颗恒星的视差（以弧度为单位）与该恒星的距离（以秒为单位）联系起来。
(定义-c:prop (c:parallax<->distance parallax distance)
(let-cell (t (AU-in-parsecs))
(c:tan parallax t)
(c:*t距离AU))
这里，特殊形式的define-c:prop定义了一种特殊的过程，一个名为c:parallax<->distance的构造器。当c:parallax<->distance被赋予两个单元，局部命名为parallax和distance，作为其参数时，它构造了一个约束传播器，将这些单元联系起来。使用特殊形式的let-单元格，它创建了两个新的单元格，一个本地名为t，另一个本地名为AU。命名为t的单元没有被初始化；命名为AU的单元被初始化为天文单位的数值，即地球轨道的半大轴，单位为帕秒。名为视差的单元和名为t的单元由c:tan构建的原始约束传播器连接，施加的约束是t持有的任何数值必须是视差持有的数值的正切值。同样地，名为t、distance和AU的单元格被一个由c:*构建的原始约束传播器所连接，施加的约束是单元格t中的值与单元格distance中的值的乘积是AU中的值。
让我们考虑一下用视差测量的织女星的距离。我们做了两个单元格，Vega-parallax-distance表示距离，Vega-parallax表示视差角。
(define-cell(define-cell Vega-parallax-distance)
织女星-视差)
现在我们可以用刚才定义的传播者构造器将我们的单元格互联起来。
(c:parallax<->distance Vega-parallax Vega-parallax-distance)
图7.3说明了这样构建的单元和传播器系统。
图7.3 这里我们看到一个传播器系统的 "接线图"，它是通过在名为Vega-parallax-distance（图中的Vega d）和Vega-parallax（图中的Vega θ）的单元上调用c:parallax<->distance构建的。圆圈表示单元，其他形状表示连接这些单元的传播器。这些传播器是没有方向性的--它们执行代数约束。按照惯例，我们用前缀c:来命名约束传播器的构造者。例如，由c:*构建的传播器执行的约束是：单元格t的内容与单元格Vega-parallax- distance的内容之积是单元格AU的内容。
如图7.4所示，约束传播器本身是由定向传播器构成的。一个定向传播器，比如由p:*构建的乘法器，会调整乘积单元中的值，使之与乘数和乘方单元中的值一致。在一个传播器系统中混合使用方向性传播器和约束性传播器是完全合适的。1 现在让我们用这个小系统来计算。Friedrich G. W. von Struve在1837年发表了对织女星视差的一个估计。2 这是第一个发表的关于恒星视差的可信测量值，但是因为他的数据很稀少，而且后来他的数据也与之相矛盾，所以第一个真正的测量值要归功于Friedrich Wilhelm Bessel，他在1838年对61 Cygni星的视差做了仔细的测量。然而，Struve的估计与目前对织女星视差的最佳估计相当接近。我们告诉我们的传播器系统，Struve的估计值是125毫秒加或减50毫秒。图7.4 由c:*构建的约束传播器是由三个定向传播器组成的。按照惯例，我们用前缀p:来命名定向传播器构造器。由p:*构建的定向乘法传播器，迫使c中的值成为单元格a和b中的值的乘积。由p:/构建的除法器传播器将其商单元（a和b）中的值强制为除数单元（c）中的值除以除数单元（b和a）中的值后的结果。
(告诉!织女星-视差
(+->interval (mas->radians 125) (mas->radians 50))
'FGWvonStruve1837)
过程tell！需要三个参数：一个传播者单元，一个该单元的值，以及一个描述数据来源的前提符号。过程mas->radians将毫秒转换为弧度。过程+->interval制作一个以其第一个参数为中心的区间。
(定义 (+->interval value delta)
(make-interval (n:- value delta) (n:+ value delta)))
因此，织女星视差单元被赋予区间
(+->interval (mas->radians 125) (mas->radians 50))
(区间3.6361026083215196e-7 8.48423941941688e-7)
Struve对其结果的估计误差是估计视差的一个相当大的部分。所以他对织女星的距离的估计是相当宽的（大约是5.7到13.3或9.5±3.8准秒）。
(get-value-in Vega-parallax-distance)
(区间5.7142857143291135 13.33333333343721)
(区间>+- (get-value-in Vega-parallax-distance))
(+- 9.523809523883163 3.8095238095540473)
这个区间值得到了前提FGWvonStruve1837的支持。
(get-premises Vega-parallax-distance)
(support-set fgwvonstruve1837)
我们将使用一个程序查询，很好地显示单元格的值和对该值的支持：3
(查询织女星视差-距离)
((vega-parallax-distance)
(has-value (interval 5.7143e0 1.3333e1))
(取决于fgwvonstruve1837)
(因为
((p:/ c:* c:视差<->distance)
(au 4.8481e-6)
(t(区间3.6361e-7 8.4842e-7)))))
1982年Russell等人报告的一个更严格的约束[106]，是
(告诉!织女星-视差
(+->interval (mas->radians 124.3) (mas->radians 4.9))
'JRussell-etal1982)
这似乎非常接近斯特鲁夫的估计中心。有了这个测量结果，距离估计就缩小到了
(查询织女星视差-距离)
((vega-parallax-distance)
(有价值(区间7.7399 8.3752))
(取决于jrussell-etal1982))
注意，我们对织女星距离的估计现在只取决于罗素的测量。因为罗素测量的区间完全包含在斯特鲁夫测量的区间内，斯特鲁夫测量没有提供进一步的信息。但是单元格记住了斯特鲁夫的测量值和它的出处，所以如果需要，它可以被恢复。
到1995年，有了一些更好的测量结果：4
(告诉!织女星-视差
(+->interval (mas->radians 131) (mas->radians 0.77))
'Gatewood-deJonge1995)
((vega-parallax)
(有价值(矛盾))
(取决于jrussell-etal1982 gatewood-dejonge1995)
(因为
((has-value (interval 5.7887e-7 6.2638e-7))
(取决于jrussell-etal1982))
((has-value (interval 6.3137e-7 6.3884e-7))
(取决于gatewood-dejonge1995))))
我们看到，这个矛盾取决于两个信息来源。每个来源都提供了一个区间，而且这些区间并不重叠。假设我们认为盖特伍德和德容格的测量结果看起来很可疑。让我们收回这个前提。
(撤消！'Gatewood-deJonge1995)
所有依赖于缩减前提的值现在都被缩减了，因此我们看到的距离的值又恢复到了
(查询织女星视差-距离)
((vega-parallax-distance)
(有价值(区间7.7399 8.3752))
(取决于jrussell-etal1982))
这就是我们从罗素等人那里得到的东西；事实上，这个前提支持了这个价值。
但是情节更加复杂，因为Hipparcos卫星（正如Van Leeuwen[83]所报告的）对织女星的视差进行了一些非常令人印象深刻的测量。
(告诉!织女星-视差
(+->interval (mas->radians 130.23) (mas->radians 0.36))
'FvanLeeuwen2007Nov)
((vega-parallax)
(有价值(矛盾))
(取决于jrussell-etal1982 fvanleeuwen2007nov)
(因为
((has-value (interval 5.7887e-7 6.2638e-7))
(取决于jrussell-etal1982))
((has-value (interval 6.2963e-7 6.3312e-7))
(取决于fvanleeuwen2007nov))))。
我们相信哪个？5 让我们拒绝罗素的结果。
(撤消！'JRussell-etal1982)
(查询织女星视差-距离)
((vega-parallax-distance)
(有价值(区间7.6576 7.7))
(取决于fvanleeuwen2007nov))
这里我们把卫星的结果隔离出来。
现在让我们把盖特伍德加回来，看看会发生什么。
(断言！'Gatewood-deJonge1995)
(查询织女星视差-距离)
((vega-parallax-distance)
(有价值(区间7.6576 7.6787))
(取决于gatewood-dejonge1995 fvanleeuwen2007nov))
我们得到了一个更有力的结果，因为范-里厄文和盖特伍德的区间的交点比任何一个都小。6（盖特伍德的结果，（区间7.589 7.6787），没有显示。）
亮度 还有其他的方法来估计与一颗恒星的距离。我们知道，恒星的视亮度会随着与我们的距离的平方而减少，所以如果我们知道恒星的内在亮度，我们就可以通过测量它的视亮度得到距离。
到现在为止，我们已经有了相当好的理论认识，可以对某些种类的恒星的内在亮度做出可靠而准确的估计。对于这些恒星，对我们从恒星收到的光的光谱分析给了我们一些信息，例如，它的状态、它的化学成分和它的质量；从这些信息中我们可以估计出内在的亮度。织女星是一个非常好的例子，我们对这颗星有很多了解。
天文学家们用星等来描述一颗恒星的亮度。5个星等的差异被定义为亮度的100倍。7 一颗恒星的内在亮度是指它在距离观测者10个准星以外的地方会出现的星等。这被称为恒星的绝对星等。我们可以用一个简洁的公式来总结亮度和距离之间的联系，这个公式结合了反平方律和星等的定义。如果M是一颗恒星的绝对星等，m是它的视星等，d是与恒星的距离，单位是秒，那么m-M=5（log10（d）-1）。这个公式可以用一个约束-传播者构造器来表示：8
(定义-c:道具
(c:magnitudes<->distance apparent-magnitude absolute-magnitude magnitud-distance)
(let-cells (dmod dmod/5 ld10 ld)
(ln10 (log 10))(1个1) (5个5))
(c:+绝对大数 dmod 视力大数)
(c:* 5 dmod/5 dmod)
(c:+一个dmod/5 ld10)
(c:* ln10 ld10 ld)
(c:exp ld magnitud-distance))
现在让我们把织女星的一些知识连起来。我们定义一些单元，并将它们与传播者相互连接。
(define-cell(define-cellVega-apparent-magnitude)
Vega-absolute-magnitude)
织女星---磁力---距离)
(c:magnitudes<->distanceVega-apparent-magnitude Vega-absolute-magnitude Vega-magnitud-distance)
我们现在提供一些测量结果。织女星非常明亮：其视亮度非常接近于零。(哈勃太空望远镜被用来做这个非常精确的测量。见Bohlin和Gilliland[14]）。
(告诉!织女星-视距-米数
(+->间隔时间0.026 0.008)
'Bohlin-Gilliland2004)
而织女星的绝对量级也是已知的，精度相当高[44]。
(告诉!Vega-absolute-magnitude
(+->间隔时间0.582 0.014)
'Gatewood2008)
因此，我们得到了一个对织女星距离的相当不错的估计，这只取决于这些测量。
(查询织女星-磁力-距离)
((vega-magnitude-distance)
(有价值(区间7.663 7.8199))
(取决于gatewood2008 bohlingilliland2004))
不幸的是，我们的距离在两个不同的单元中，所以让我们用一个传播器来连接它们。
(c:相同的织女星-磁力-距离 织女星-视差-距离)
在这一点上，我们有一个更好的到织女星的距离值--这个区间的高端与之前相同（在第336页），但其低端要高一点。
(查询织女星视差-距离)
((vega-parallax-distance)
(有价值(区间7.663 7.6787))
(取决于fvanleeuwen2007nov gatewood-dejonge1995 gatewood2008 bohlingilliland2004)
Gatewood和de Jonge的1995年测量在这里真的重要吗？让我们拭目以待。
(撤消！'Gatewood-deJonge1995)
(查询织女星视差-距离)
((vega-parallax-distance)
(有价值(区间7.663 7.7))
(取决于fvanleeuwen2007nov gatewood2008 bohlingilliland2004))
确实如此。1995年的测量结果拉到了该区间的高端。
测量结果得到改善我们有两种方法来计算与织女星的距离--从视差和星等中计算。这里有一些值得注意的地方：视差和星等的测量间隔都是利用来自另一个的信息来改进的。为了使该系统保持一致，这是必须的。
看一下织女星的视星等。Bohlin和Gilliland提供的原始测量值是m = 0.026 ± 0.008。这就转化为区间
(+->间隔时间0.026 0.008)
(区间.018.034)
但现在的数值要好一点--[0.018, 0.028456]。
(查询织女星-表象-米高)
((vega-apparent-magnitude)
(has-value (interval 1.8e-2 2.8456e-2))
(取决于gatewood2008 fvanleeuwen2007nov bohlin-gilliland2004))
为了与视差测量的信息保持一致，必须将高端拉进来。这对每个可测量的量来说都是如此。Gatewood 2008（第338页）提供的绝对量级是。
(+->间隔时间0.582 0.014)
(间隔时间.568.596)
但现在低端被拉进来了。
(查询Vega-absolute-magnitude)
((vega-absolute-magnitude)
(has-value (interval 5.8554e-1 5.96e-1))
(取决于gatewood2008 fvanleeuwen2007nov bohlin-gilliland2004))
视差也被来自星等测量的信息所改进。
(查询织女星-视差)
((vega-parallax)
(has-value (interval 6.2963e-7 6.3267e-7))
(取决于fvanleeuwen2007nov gatewood2008 bohlin-gilliland2004))
计算向所有方向传播的事实给了我们一个强大的工具来理解任何新信息的影响。
练习7.1。让编写传播器网络更容易 在我们的传播器系统中，编写代码来构建哪怕是一个简单的网络也是相当痛苦的，因为所有内部节点都必须被命名。例如，一个在摄氏和华氏温度之间转换的约束传播器看起来像。
(define-c:prop (celsius fahrenheit)
(let-cell (u v (nine 9) (five 5) (thirty-two 32))
(c:* 摄氏九度u)
(c:* v 五 u)
(c:+ v三十二华氏度))
如果能够对一些传播者使用表达式语法，那就更好了，所以我们可以写。
(define-c:prop (celsius fahrenheit)
(c:+ (ce:* (ce:/ (常数9) (常数5))
摄氏度)
(常数三十二)
华氏度））。
这里的ce:*和ce:+是传播者构造器，为数值创建单元格，并将其返回给调用者。程序ce:+可以这样写
(定义 (ce:+ x y)
(let-cells (sum))
(c:+ x y sum)
(sum))
除了约束性传播器，还有方向性传播器，如p:+。这种表达形式的一个好名字是pe:+。
我们可以获得所有原始算术运算符的名称。编写一个程序，利用这些名称，为每个运算符安装定向和约束表达式。
练习7.2:一个电气设计问题 注意：你不需要知道电子学来做这个问题。
Anna Logue正在设计一个晶体管放大器。作为她计划的一部分，她需要制作一个分压器来给一个晶体管提供偏压。分压器由两个电阻组成，电阻值为R1和R2。ρ是输出电压Vout与电源电压V in的比率。还有一个Z，是分压器的输出电阻。
下面是相关的方程。由于安娜有很多这样的问题要解决，所以她做了一个约束网络来帮助她：a. 做一个实现这个图的传播者网络。
b.安娜有一个电压在14.5和15.5伏之间的电源，她需要分压器的输出在3.5和4.0伏之间。Vin∈[14.5，15.5]，Vout∈[3.5，4.0]。
她有一个47000欧姆的电阻R2的库存。她可以从中选择R1的数值范围是多少？c. 安娜还需要分压器的输出电阻在20000和30000欧姆之间。Z ∈ [20000, 30000].
因此，她真正的问题是在所需的分压比ρ和Z的规格下，为分压电阻R1和R2找到适当的数值范围。
如果她不选择R2（记得收回对这个值的支持！），而是选择断言Z规范，这应该决定R1和R2；但网络不会找到R2的值！。为什么？解释一下这个问题。
d.如果我们现在告诉R2是在1000欧姆到500000欧姆的某个范围内，传播者网络将收敛，对R2的真实范围给出一个有用的答案。为什么？解释一下吧!练习7.3：局部一致性--一个项目 传播是攻击局部一致性问题的一种方法。例如，华尔兹算法[125]是一种解释实心多面体的线图的传播方法。地图着色和类似的问题都可以用传播法成功攻克。
其基本思想是，有一个带有节点的图，这些节点可以被分配到一组离散的标签中的一个，并且这些节点通过约束条件相互连接，这些约束条件根据相邻节点的标签来限制哪些标签是允许的。例如，在华尔兹算法中，一条线可以有几个标签中的一个。每条线连接着两个顶点。一个顶点约束终止于该顶点的线，使其与顶点的一组可能的几何解释之一相一致。但是，一条线的解释在线的两端必须是相同的。
a.对于这些实验，你将需要一个离散集合的 "算术"。你将需要联合，交叉，以及一个集合在另一个集合中的补数。建立这样一个算术。
b.一个节点的可能性集合是关于该节点实际状态的部分信息：可能性集合越小，我们对该节点的信息越多。如果我们把关于节点状态的知识表示为一个传播单元，两个集合的合并就是它们的交集。这与实值范围的区间相交是一致的。让离散集的相交成为通用合并的处理程序。
c.利用这个组织建立并展示你对一个本地一致性问题的解决方案。
d.请注意，在许多图中，节点的分配只取决于少数的约束条件。说明如何使用支持度跟踪来对节点的分配作出解释。
7.2 传播机制 基本的传播机制由单元、传播器和调度器组成。一个单元积累关于一个值的信息。它必须能够说出它所拥有的信息，并且它必须能够接受对该信息的更新。它还必须能够提醒对其内容感兴趣的传播者有关其内容的变化。每个单元都有一组可能对其内容感兴趣的传播者，这些传播者被称为邻居。
传播器是一个无状态（功能）程序，通过它所关注的任何单元的值的变化来激活。可以激活传播器的单元是其输入单元。被激活的传播器从其输入单元收集信息，并可以为一个或多个输出单元计算更新。一个单元可以既是传播器的输入又是输出。
一个细胞的内容是它所积累的关于其价值的信息。当被问及它的价值时，例如被一个传播者问及，它就会用它能提供的最强的价值来回应。我们在区间的使用中看到了这一点--一个单元报告它所知道的关于其价值的最紧密的区间。当一个单元收到输入时，它确定其内容的变化是否会使其最强值发生变化。如果最强值发生变化，该单元就会提醒其邻居。这就告诉调度器要激活它们。调度器负责将计算资源分配给被激活的传播者。其目的是使传播的计算结果与调度的细节或顺序无关。
细胞和传播者是以层次结构组织的元素。
每个单元或传播者都有一个名称，一个父级，也许还有一组子级。这些都是用来为层次结构中的每个单元或传播者构建唯一的路径名称。路径名称可用于访问该元素，并在打印输出中识别它。单元或传播器是由用户或复合传播器制作的。
参数*my-parent*是由父体动态绑定的。
这使新的细胞或传播者能够附着在家族中。
7.2.1 单元 一个单元被实现为一个接受消息的过程，使用bundle宏。单元将其信息保存在内容变量中，该变量被初始化为一个值the-nothing（由谓词nothing?标识），代表没有任何关于该值的信息。当被问及时，单元格报告的值是它目前拥有的最强值。单元还维护着它的邻居列表，即当单元的最强值发生变化时需要被提醒的传播者。一个辅助数据结构relation被用来保存单元的家族关系。
下面是一个单元格构造函数的概要。有趣的部分是add-content！和test-content！，解释如下。
(定义 (make-cell name)
(让((关系(make-relations name (*my-parent*)))
(邻居们'())
(content the-nothing)
(最强的无))
(定义 (get-relations) 关系)
(定义 (get-neighbors) neighbors)
(定义 (get-content) content)
(定义 (get-strongest) 最强)
(定义 (add-neighbor! neighbor)
(set! neighbors (lset-adjoin eq? neighbors neighbor)))
(定义 (add-content! increment)
(set! content (cell-merge content increment))
(test-content!))
(define (test-content!)
见第345页的定义）。
(定义我
(bundle cell? get-relations get-neighbors get-content get-strongest add-neighbor! add-content! test-content!)
(添加孩子！我 (*我的父母*))
(set!*(cons me *all-cells*))
我））。
一个单元格通过调用add-content来接收新信息！。
新的信息，增量，必须与内容中的现有信息合并。一般来说，合并过程是针对被合并的信息种类的，所以必须指定单元的合并机制。然而，代表没有信息的the-nothing是特殊的。任何与the-nothing合并的信息都会被原样返回。
合并而不是替换的原因是利用部分信息来完善我们对数值的认识。9 例如，在上面描述的恒星距离的计算中，区间被合并以通过交叉产生更好的估计。在类型推理的例子中（见第4.4.2节），我们通过统一来合并描述以获得更具体的信息。我们将在第7.4节研究合并数值的一般问题。
在某些情况下，可能无法合并两个信息。例如，一个未知数的值不能既是零又是一。在这种情况下，cell-merge会返回一个矛盾对象，它可能带有关于冲突的细节信息。如果没有额外的信息，矛盾对象就是符号the-contradiction，它满足原始的谓词contradiction?更复杂的矛盾由通用谓词程序general-contradiction检测。矛盾被解决，如果可能的话，通过handle-cell-contradiction，如7.5节所解释的。
如果该单元的最强值发生变化，邻居就会收到警报。
但如果一个增量不影响最强的值，它就不会提供额外的信息；在这种情况下，重要的是避免提醒邻居，以防止无用的循环。所有这些都是由test-content！程序实现的，它被定义为make-cell的一个内部程序。
(define (test-content!)
(让((最强*(最强值内容)))
(cond ((equivalent? strongest strongest*)
(设置！最强最强*)
'content-unchanged)
((一般-矛盾？最强*)
(设置！最强最强*)
(handle-cell-contradiction me)
'的矛盾）。
(否则
(设置！最强最强*)
(警报-传播者! 邻居们)
'content-changed))))
当一个前提改变其信念状态时，程序test-content！也被用来提醒所有单元。每个被提醒的单元检查其最强值是否发生了变化，需要采取一些行动，如发出矛盾信号或提醒其传播者邻居。见第7.3节。
为了隐藏一个单元的实现细节，我们提供了方便的访问程序。
(定义 (add-cell-neighbor! cell neighbor)
(细胞'添加-邻居！邻居))
(定义 (add-cell-content! cell increment)
(参数化((current-reason-source cell))
(单元格'添加内容！增量)))
(定义 (cell-strongest cell)
(单元格'get-strongest))
add-cell-content！中的current-reason-source参数是为每个值提供理由的层的一部分，如第333页的脚注3所述。这个有用的功能在这里就不进一步阐述了。
7.2.2 传播器 为了制造一个传播器，我们提供了一个输入单元的列表，一个输出单元的列表，以及一个在被提醒时执行的程序activation！。构造器用add- cell-neighbor将传播器引入其输入单元。它还提醒新的传播器，以便在需要时运行它。
(定义(传播者输入输出激活! 名称)
(让((关系(make-relations name (*my-parent*)))))
(定义 (get-inputs) 输入)
(定义 (get-outputs) 输出)
(定义 (get-relations) 关系)
(定义我
(bundle propagator? activate! get-inputs get-outputs get-relations))
(添加孩子！我 (*我的父母*))
(for-each (lambda (cell)
(添加小区邻居！小区我))
输入）。
(提醒-传播者！我)
我））。
原始传播器是有方向性的，因为它们的输出不会与它们的输入重叠。我们用产生单一输出的Scheme程序制作原始传播器。按照惯例，我们通过将输入单元和输出单元放在一起，最后才是输出，来构建一个原始传播器。我们可以制作一个产生多个输出的原始传播器，比如带余数的整数除法，但我们在此不需要这样。
(define (primitive-propagator f name)
(lambda细胞
(让((输出(车(最后一对细胞)))
(输入(除最后一对单元)))
(传播者输入 (列表输出)
(lambda ()
(让((input-values (map cell-strongest inputs)))
(if (any unusable-value? input-values)
无所事事
(add-cell-content! output)
(apply f input-values)))))
name))))
当激活时，传播者可以选择使用f来计算一个结果。对输入值调用f的结果被添加到输出单元。我们称这个选择过程为激活策略。这里我们要求所有的输入都是可用的值。默认情况下，矛盾对象和the-nothing是不可用的，尽管我们以后可以添加其他的。其他政策也是可能的。
传播者可以通过组合其他传播者来构建。
我们通过提供一个程序--build来制造复合传播器，该程序从各个部分建立所需的网络。一个复合传播器在需要进行计算时才会被构建。但只有当数据到达它的一个或多个输入单元以激活它时，才会出现这种需求。然而，我们不希望每次在其输入单元中获得新值时都要重建复合传播器网络，所以构造函数必须确保它只被构建一次。这是用一个布尔标志build?来安排的，该标志在构建完成后被设置。
(define (compound-propagator inputs outputs to-build name)
(让((建? #f))
(define (maybe-build))
(如果(或建?
(和 (不是 (null? inputs))
(每一个不可用的价值？
(map cell-strongest inputs))))
无所事事
(开始(参数化((*我的父母*我))
(to-build))
(设置！建立？#t)
'建成)))
(定义我
(传播者的输入输出可能是建立名称))
我））。
复合传播器的激活策略与原始传播器的激活策略不同。在这里，如果任何输入都有可用的值，我们就建立网络。这是很合适的，因为即使不是所有的输入都可用，网络的某些部分也可能做一些有用的计算。
参数化机制是为了支持传播器元素的分层组织。它使复合传播器成为构建网络过程中任何单元或传播器的父本。
如第332页图7.4所述，约束传播器是通过组合方向性传播器来构建的。例如，我们可以把执行两个单元格中的值的乘积是第三个单元格中的值的约束的传播器做成如下样子。
(定义-c:prop (c:* x y product)
(p:* x y 产品)
(p:/ product x y)
(p:/ product y x))
在这里我们看到，三个方向性的传播器被合并起来，形成约束。这可以工作，因为我们合并了数值而不是替换它们，而且等价的数值不会传播。如果等值传播，任何类似c:*传播器的东西都将是一个无限循环。10 宏定义-c:prop只是语法上的糖。该宏产生的实际代码是。
(定义 (c:* x y product)
(约束性传播者
(list x y product)
(lambda ()
(p:* x y 产品)
(p:/ product x y)
(p:/ product y x))
'c:*))
其中约束-传播者只是。
(define (constraint-propagator cells to-build name)
(compound-propagator cells cells to-build name))
所有与约束传播器相关的单元都是输入和输出单元。
7.3 多种可供选择的世界观 在我们的恒星距离的例子中，我们表明每个值都带有在其计算中使用的前提支持集，以及该值的 "原因"（产生它的传播者和它是由哪些值产生的）。这是用我们在第6.4节介绍的分层数据机制完成的。但是有些 "事实 "是相互不一致的。在我们的例子中，我们调制了对前提的信念，以获得局部一致的世界观，这取决于我们选择相信哪个前提。
一个前提要么进入（相信），要么退出（不相信）。在我们的例子中，用户可以断言！一个前提使其进入或收回！将其踢出。这个系统的 "魔力 "在于，单元格中的可观察值总是那些被完全支持的值--那些支持的前提都在其中的值--即使前提中的信念被改变。11 当支持的信念状态发生变化时，重新计算所有的值是很愚蠢的。我们可以做得更好，记住那些目前不被完全支持的价值。这使我们能够重新断言一个前提，并恢复它所支持的价值，而不需要重新计算这些价值。当一个前提的信念状态发生变化时，单元格必须检查其最强值是否发生了变化。这是通过调用每个单元的test-content！来实现的；每个最强值发生变化的单元都会提醒依赖于该单元值的传播者。然后，每个传播器获得其输入单元格内容的最强值，并计算（或重新计算！）其输出值。如果该输出值等同于已经存储在输出单元中的最强值，就不会有进一步的行动。如果输出单元中最强值的信念状态发生变化，这将导致其邻近的传播者重新计算。
但是，输出单元中最强的值可能有独立的支持，在这种情况下，传播将停止在这里。
为了使其发挥作用，在每个单元格中，内容可以持有一组值（值集）与它们所依赖的前提相配。
单元从内容中提取最强值，并将其保存在本地变量strongest中，可以用cell-strongest来访问。最强值是集合中完全支持的值中的最佳选择，12如果集合中没有一个值是完全支持的，则为无。
剩下的就是阐释最强值，它必须能够在原始数据、分层数据和价值集上操作。因此，让它成为一个通用程序是合适的。一个没有注释的数据项的最强值只是那个数据项，所以这提供了默认值。
(定义最强值
(simple-generic-procedure 'strongest-value 1)
(lambda (object) object) ))
如果一个分层数据项被完全支持，那么它的最强值就是它自己，否则它的最强值就是没有信息。
(define-generic-procedure-handler strongest-value
(match-args layered-datum?)
(lambda (elt)
(if (all-premises-in?(support-layer-value elt))
毫无意义））。
一个价值集的最强值是该价值集的最强后果。
(define-generic-procedure-handler strongest-value
(match-args value-set?)
(lambda (set) (strongest-sequence set)))
最强结果程序只是将一个值集中完全支持的元素合并在一起。它使用merge- layered来确定值集中完全支持的值的 "最佳选择"（见7.4.2节）。如果没有完全支持的值，就没有任何信息，所以结果是--没有。
(定义 (最强序列集)
(fold (lambda (increment content)
(合并分层的内容增量))
无的
(过滤 (lambda (elt)
(所有房舍在?
(support-layer-value elt)))
(value-set-elements set))))
7.4 合并数值 我们还没有解决合并数值的含义。这是一个复杂的过程，有三个部分：合并基本值，比如数字和区间；合并支持的值；以及合并值集。add-content！中的程序cell-merge必须分配给被传播的数据的适当合并。在第366页，setup-propagator-system将cell-merge初始化为merge-value-sets。
7.4.1 合并基值 在我们的传播者系统的例子中只有几种基值类型：the-nothing , the-contradiction , numbers, booleans, and intervals。数字和布尔运算很简单，因为只有相等的值才能被合并。如果它们不能被合并，那就是一个矛盾。任何与the-nothing合并的东西都是它自己。
任何与 "矛盾 "合并的东西都是 "矛盾 "的。
合并程序对基值是通用的，默认的处理程序处理所有的简单情况--除了间隔。
(定义合并
(simple-generic-procedure 'merge 2)
(lambda (content increment)
(cond ((nothing? content) increment)
((无?增量)内容)
((矛盾？内容)内容)
((矛盾？增量)增量)
((等同于？内容增量)内容)
(否则the-contradiction)))))
在天文学的例子中，我们也有区间运算，所以我们需要能够合并区间。
(定义 (merge-intervals content increment)
(让((new-range (intersect-intervals content increment)))
(cond ((interval=? new-range content) content)
((interval=? new-range increment) increment)
((empty-interval? new-range) the-contradiction)
(否则new-range))))
我们可以将一个数字与一个区间合并。如果数字包含在区间内，我们就可以得到这个数字，否则就会出现矛盾。
(定义 (merge-interval-real int x)
(if (within-interval? x int)
x-contradiction))
这一切都被粘在一起，成为一个通用程序处理程序。
(define-generic-procedure-handler merge)
(any-arg 2 interval? real? )
(lambda (x y)
(cond ((not (interval? x))(merge-interval-real y x))
((not (interval? y))(merge-interval-real x y))
(else (merge-intervals x y)))))
没有其他基值合并的情况。
7.4.2 合并支持的值 支持的值是作为一个分层的数据项实现的，它有一个支持层和被传播的基础值。所以支持的值的合并必须是一个分层程序。
(定义合并-分层
(make-layered-procedure 'merge 2 merge))
支持层用support:merge来实现合并，它被赋予三个参数：由基础层计算的合并值、当前内容和新的增量。support:merge的工作是为合并后的值提供合适的支持集。如果合并后的值与内容的值或增量的值相同，我们可以使用该参数的支持。但是如果合并后的值是不同的，我们需要结合支持。
(定义 (support:merge merged-value content increment)
(cond ((equivalent? merged-value)
(基础层-价值内容))
(support-layer-value content))
((等同于？合并后的价值
(底层价值增量))
(support-layer-value increment))
(否则
(support-set-union
(support-layer-value content)
(support-layer-value increment))))))
(define-layered-procedure-handler merge-layered support-layer support:merge)
在这里，define-layered-procedure-handler被用来将过程support:merge附加到分层过程merge-layered上，作为其支持层的处理程序。
7.4.3 合并价值集 要合并价值集，我们只需把增量的元素加入到内容中，就可以形成一个新的集合。注意，->value-set会把它的参数胁迫成一个值集。
(定义 (merge-value-sets content increment)
(如果(无？增量)
(->value-set content)
(value-set-adjoin (->value-set content) increment)))
当把一个新的元素与内容相连接时，如果该元素被任何现有的内容元素所包含，我们就不添加该元素。
(定义 (value-set-adjoin set elt)
(if (any (lambda (old-elt)
(Element-subsumes? old-elt elt))
(value-set-elements set))
设置
(make-value-set
(lset-adjoin equivalent?
(value-set-elementselt))))
集）。
归并的标准有点复杂。如果一个元素的基值至少和另一个元素的基值一样有信息量，而且它的支持是另一个元素的子集，那么这个元素就会取代另一个元素。(注意：一个较小的支持集是一个较强的支持集，因为它依赖于较少的前提）。
(定义 (element-subsumes? elt1 elt2)
(和 (value-implies?(底层价值 elt1)
(底层价值 elt2))
(support-set<= (support-layer-value elt1)
(support-layer-value elt2))))
过程value-implies? 是一个通用的过程，因为它必须能够处理许多种基础数据，包括区间。
练习7.4：合并与统一 我们已经看到，部分指定一个数值的区间如何被合并以获得关于这个数值的更具体的信息。
另一种部分信息是象征性的模式，有缺失信息的漏洞。这种信息可以用统一来合并，如第4.4节所述。我们用统一来实现类型推理的一个简单版本，但它可以更普遍地用于合并部分指定的符号表达式。第4.4节中关于本-富兰克林的记录的组合的例子可能是有提示意义的。组织传播者系统的一种方式是，每个单元是一个小型数据库，仅限于关于某些特定事物的信息。连接单元的传播者是可以进行演绎的方式。例如，一个有希望的领域是点集拓扑学中的拓扑空间的分类。另一个是你生活群体的组织--例如，房间的相邻关系和居民的社会关系。挑选一个你认为有趣的领域。请发挥你的想象力！a. 设计一个传播者网络，其中每个单元将持有某种特定的符号信息。例如，一个单元可以代表对麻省理工学院学生的了解。这些信息可能是姓名、地址、电话号码、班级年级、专业、生日、最好的朋友......这就需要设计一个可扩展的数据结构，可以容纳这些信息和更多的信息。你还需要将这些人联系起来的传播者。因此，你可能会从一个人，或从多个人那里得到关于另一个人的信息。这可能是一个不错的八卦模型。制作一些原始的传播器来操作这些符号量，并建立一个有趣的网络。
b.增加统一作为合并的通用程序处理程序，并展示如何使用它来合并来自多个来源的部分符号信息。
c.发现一些有趣的复合符号传播器，可以用来表示网络中相关主体的常见连接组合。
7.5 搜索可能的世界 如果搜索是不必要的就好了。不幸的是，对于许多类型的实际问题，"为了论证而假设 "一些可能不是真的东西是有帮助的。然后，我们就会计算出这个假设的后果。如果这个假设导致了矛盾，我们就收回假设并尝试其他的东西。但在任何情况下，该假设都可能促成其他有助于解决问题的推论。
我们在第5.4节中开始探索这个想法，在那里我们介绍了amb并将其用于搜索问题。在那些关于amb的冒险中，我们是在一种面向表达式的语言中工作的，这种语言的执行顺序受到表达式评估方式的限制。我们通过痛苦地使用延续程序，部分地将自己从这种约束中解脱出来，或者将求值器结构化，明确地传递延续程序（在第5.4.2节），或者通过call/cc使用Scheme的隐式延续程序。
(在5.5.3节）。但是，即使有了call/cc，我们也没有对搜索过程进行充分的控制。
在第6.4节中，我们展示了如何将每个值与一个支持集联系起来，即该值所依赖的前提集。如果每个假设都被贴上一个新前提的标签，我们就可以准确地知道导致矛盾的假设组合。如果我们很聪明，我们可以在以后的搜索中避免断言那个假设组合。但是在表达式的评估中，很难将假设的断言与控制流隔离开来。
问题是，在表达式语言中，选择决策是在表达式被评估时做出的，产生一个分支决策树。决策树是按某种顺序评估的，例如，深度优先或广度优先。任何决策序列的后果都是在决策做出后评估的。如果遇到失败（注意到矛盾），只有进化分支上的决策可能是罪魁祸首。但是，如果只有分支上的一些决策有问题，可能有一些无辜的决策是比最后的罪魁祸首更晚做出的。
仅仅依赖于无罪决定的计算在回溯到最后一个罪魁祸首时就会丢失。因此，将一个分支撤回到一个较早的决定可能需要失去很多有用的推理。
相比之下，在实际问题中，决策的后果通常是局部的和有限的。例如，在解决一个填字游戏时，我们经常被卡住--我们无法填上任何我们确定的空白。但是我们可以通过假设某个盒子里有一个特定的字母来取得进展，而没有很好的证据来证明这个假设。假设盒子里有那个字母，就可以进行推理，但最终可能发现这个假设是不正确的，必须收回。然而，自该假设以来的许多推论都是正确的，因为它们并不依赖于该假设。我们不会仅仅为了消除错误假设的后果而收回这些正确的推论。我们希望错误假设的实际后果被收回，留下其他假设的后果被相信。这在面向表达的语言系统中是相当难安排的。
通过传播器，我们摆脱了基于表达式评估的控制结构，代价是将传播器视为平行运行的独立机器。因为一个传播器单元可能包含一个元素为分层值的值集，所以我们可以将一个支持集与每个值联系起来。在传播器系统中，只有当其支持集中的所有前提都被相信时，一个价值才被相信；而且只有被相信的价值才被传播。这样一来，我们就有能力通过独立调节每个前提的信仰状态来转换世界观。
一些前提的组合是矛盾的。当系统试图合并两个不相容的完全支持的值时，就会发现矛盾，从而得出一个矛盾对象。矛盾对象有一个支持集，其中有那些意味着矛盾的前提。
为了使其发挥作用，我们引入了一个类似于amb的选择传播器，它对它所控制的单元的价值进行了假设。
每个假设都由选择传播者创建的假设前提来支持，它可以断言或收回。传播者网络计算网络中的选择传播者对假设值进行替代性分配的后果，直到找到一致的分配。
一个例子。勾股定理三段论 考虑寻找10以内的自然数的勾股定理三段论的问题。(我们在第272页考虑了一个类似的问题。
在这里，我们正在设置一个更笨的算法！）。我们可以将其表述为一个传播者问题。
(定义 (Pythagorean)
(让((可能性'(1 2 3 4 5 6 7 8 9 10))
(let-cells (x y z x2 y2 z2)
(p:amb x可能性)
(p:amb y可能性)
(p:amb z可能性)
(p:* x x x2)
(p:* y y y2)
(p:* z z z2)
(p:+ x2 y2 z2)
(list x y z))))
这段代码构建了一个带有三个乘法器推进器和一个加法器推进器的推进器网络，如果单元格x、y和z中的值是一个毕达哥拉斯式的三联体，就会得到满足。每个单元格都与一个选择传播器相连，该传播器由p:amb创建，将从可能性中选择一个元素。
要运行这个，我们必须首先初始化传播者系统。
(initialize-scheduler)
现在我们可以构建传播者网络，并从中提取所有的三元组。过程pythagorean构建了传播者网络，并返回一个感兴趣的三个单元的列表。
程序run开启了调度器，从而运行网络。在运行过程中，选择传播者提出x、y和z的值，直到发现无法解决的矛盾或网络变得静止。如果没有发现矛盾，运行返回完成，并打印出每个有趣单元的最强值的基础值。然后，该值的组合被拒绝，并继续循环，对run进行新的调用。
(让((答案(Pythagorean)))
(让 try-again ((result (run)))
(if (eq? result 'done)
(开始
(pp (map (lambda (cell)
(get-base-value
(单元-最强单元)))
答案））。
(强制-失败！答案)
(try-again (run)))
结果))
(3 4 5)
(4 3 5)
(6 8 10)
(8 6 10)
(矛盾#[单元格x])
7.5.1 依赖导向的回溯 依赖导向的回溯是一种强大的技术，它通过避免断言支持任何先前发现的矛盾的前提集，来优化回溯搜索。当一个单元格包含两个或两个以上的矛盾值时，这些值的支持集的联合体就是一个nogood集。
当检测到一个矛盾时，该矛盾的nogood集被保存，以让回溯者知道不要再尝试该组合。为了方便回溯机制，nogood集不被直接存储：它被分配给nogood集的每个前提。每个前提都会得到一个去除自身的集合的副本。例如，如果nogood集是{A B C ...}，那么前提A就会得到{B C ...}，前提B得到集合{A C ...}，以此类推。对于任何给定的前提，从该前提参与的矛盾中积累的所有部分nogood集的列表，可以通过前提-nogoods访问器获得。
一旦nogood集被保存，回溯者从nogood集（如果有的话）中选择一个假设的前提，并收回它。
回溯会激活那些与该假说之前支持的值相邻的单元格的传播者，包括最初断言该假说的传播者，如果可能的话，会使该传播者断言一个不同的假说。如果在nogood集合中没有假设前提，回溯器就没有选择，所以会返回一个失败。
当然，有很多簿记工作需要做，以使其发挥作用。让我们了解一下如何实施。
假设是由二进制amb构成和控制的 最简单的选择传播器是由二进制amb构建的。在一个单元格上调用二进制-amb的结果是一个二进制-amb传播器，该单元格既是输入也是输出。二进制amb传播器将单元格的值调制为真或假，直到找到一个一致的赋值。
程序binary-amb引入了两个新的前提，它们被标记为假设性前提。假设性前提是指允许根据需要自动改变其信念的前提。
binary-amb程序用一个矛盾来初始化单元：程序make-hypotheticals创建了一个真值和一个假值，每个都有一个新的假设前提支持，并将这两个值添加到单元的内容中。添加这些值会激活单元格，调用其test-content！程序，从而启动矛盾处理机制，最终向不快乐的单元格的binary-amb传播者发出警告。
然后，这个矛盾将被二进制-amb传播者的激活！程序amb-choose所修复。
(定义 (binary-amb cell)
(let ((premises (make-hypotheticals cell '(#t #f)))))
(让((true-premise (car premises))
(false-premise (cadr premises)))
(定义 (amb-choose)
(让((原因-反对-真实
(filter all-premises-in?
(premise-nogoods true-premise))
(理由-反对-虚假
(filter all-premises-in?
(前提-nogoods false-premise)))))
(cond ((null? reasons-against-true)
(mark-premis-in! true-premise)
(mark-premise-out! false-premise))
((null? reasons-against-false)
(mark-premise-out! true-premise)
(mark-premise-in! false-premise))
(否则
(mark-premise-out! true-premise)
(mark-premise-out! false-premise)
(过程-矛盾
(pairwise-union reasons-against-true reasons-against-false)
cell)))))
(让((我(传播者(列表单元格)(列表单元格))
amb-choose 'binary-amb)))
(set! all-amb-propagators)
(cons me all-amb-propagators))
me))))
amb-choose程序使用前提nogoods来确定支持真值的前提或支持假值的前提是否可以被相信。一个前提的前提nogoods的每个元素都是一组前提，如果它们都被相信，则该前提不能被相信。因此，如果amb-选择发现一个前提的任何完全支持的前提nogood，这个前提就不能被相信。
如果支持真值的前提或支持假值的前提是可信的，amb-choose分别断言为真或假。如果两者都不可信，它就推迟到更高层次的矛盾处理（过程-矛盾），希望在其他前提的信念被调节后，当这个传播者被重新激活时，有可能断言为真或假。
通过pairwise-union构建的过程矛盾的论证是一组nogoods。每一个nogoods都是一组排除了真选择的前提和一组排除了假选择的前提的结合。因此，这些nogoods中的任何一个都会阻止人们选择任何一种选择。14
(定义 (pairwise-union nogoods1 nogoods2)
(append-map (lambda (nogood1)
(map (lambda (nogood2)
(support-set-union nogood1 nogood2))
nogoods2))
nogoods1))
从矛盾中学习 程序process-contradictions保存了它收到的所有nogoods，将nogoods中的信息分配给前提的nogoods。然后，它选择一个nogood，通过收回它的一个假设前提（如果有的话）来拒绝相信。
(define (process-contradictions nogoods complaining-cell)
(更新-失败-计数！)
(for-each save-nogood! nogoods)
(let-values (((to-disbelieve nogood)
(选择倾向于不相信nogoods))
(可能是踢出去的要相信nogood的抱怨-cell))
程序save-nogood！将给定的nogood集合中的每个前提的前提-nogood与它不相容的其他前提集合进行扩充。这就是系统从过去的失败中学习的方式。被更新的前提不包括在它自己的前提nogood集中，因为一个前提可能不会与它自己不兼容。
(定义 (save-nogood! nogood)
(for-each (lambda (premise)
(设置前提------nogoods!
(adjoin-support-with-subsumption
(support-set-remove nogood premise)
(前提-nogoods premise)))))
(support-set-elements nogood))
新的前提nogood可以归入或被现有的前提nogood之一所归入；最小的前提nogood是最有用的。
解决矛盾 矛盾的解决方式是收回nogood集中支持矛盾的一个前提。唯一可以收回的前提是假设，它是 "为了论证 "而断言的。如果有一个以上的nogood集支持一个矛盾，我们选择一个假设数量最少的，因为不相信一个小的nogood集比不相信一个假设数量较多的nogood集排除了更多的可能性。
(define (choose-premise-to-disbelieve nogoods)
(选择第一种假设性的
(车 (sort-by nogoods
(lambda (nogood)
(counthypothetical?
(support-set-elementsnogood)))))))
然而，从选定的nogood集中选择哪个假设来拒绝并不明显。在这里，我们任意选择nogood集合中的第一个假设前提。
(定义 (选择先验-假设nogood)
(让((hyps (support-set-filter hypothetical? nogood)))
(价值（和（不（支持-集-空？ hyps））。
(car (support-set-elements hyps)))
nogood)))
maybe-kick-out程序完成了解决矛盾的工作。如果选择者能够找到一个合适的假说来否定它，那么这个假说就会被收回，传播就会正常进行。否则，传播过程将被停止，并告知用户矛盾的存在。
(定义 (maybe-kick-out to-disbelieve nogood cell)
(如果不相信
(标记-保留-退出！对-不相信)
(abort-process (list 'contradiction cell)))))
在单元格中发现的矛盾 如果在向单元格添加内容的过程中发现了矛盾，不高兴的单元格会以自己为参数调用handle-cell-contradiction。这时，单元格中最强的值是矛盾对象，而矛盾对象的支持是刺激性的nogood集。这可以交给进程-矛盾来处理。
(定义 (handle-cell-contradiction cell)
(let ((nogood (support-layer-value (cell-strongest cell)))))
(process-contradictions (list nogood) cell)))
这就是为支持依赖关系导向的回溯所需要做的一切。
非二进制 amb 尽管二进制amb可以用于许多问题的表述，但大多数选择都不是二进制的。通过建立一个由单元格控制的条件传播器电路，可以从二进制amb中构建一个n-ary选择机制，这些单元格的真假值是由二进制amb传播器调制的，但这是非常低效的，而且引入了很多额外的机器。所以我们用p:amb提供了一个原生的n-ary选择机制。程序p:amb与二进制amb类似。对于二元amb来说，单元格中的值正好有两个选择，#t或#f，而且每个选择都有一个假设的前提支持。当p:amb被应用于一个单元格和一个可能的值列表时，程序make-hypotheticals将这些值添加到单元格中，每个值都有一个新的假设前提支持。
当由p:amb构建的传播者被激活时，程序amb-choose被调用。它首先试图在它的假设中找到一个没有被其前提-nogoods所排除的假设前提。如果有一个，它就把这个前提标入，并把其他所有的前提标出，从而选择与这个前提相关的值作为单元格的值。如果没有一个假设的前提可以被相信，它就把所有的前提标记出来，并制作一组新的nogoods来传递给process- contradictions，如果可能的话，它将从这些nogoods中撤回一个假设的前提。将pairwise-union的程序推广到两个以上的集合，就是cross- product-union。如前所述，这是一个解决步骤。
(定义 (p:amb cell values)
(让((前提(make-hypotheticals cell values)))
(定义 (amb-choose)
(让((要-选择
(找到 (lambda (premise)
(不是(任何所有房地产业者在?
(前提-nogoods premise)))))
房舍）））。
(如果要选择
(for-each (lambda (premise)
(如果(eq? premise to-choose)
(mark-premise-in! premise)
(mark-premise-out! premise)))
房舍)
(让((nogoods
(cross-product-union
(map (lambda (premise)
(filter all-premises-in?
(前提-nogoods前提))
处所))))
(for-each mark-premise-out! premises)
(过程-矛盾 nogoods cell)))))
(让((我(传播者(列表单元格)(列表单元格))
amb-选择'amb)))
(set! all-amb-propagators)
(cons me all-amb-propagators))
我））））
用p:amb构建的选择传播者只引入了与选择一样多的假设前提。基于二进制amb的n>2个选择的构造引入了大约两倍的前提。
7.5.2 解决组合谜题 为了证明使用依赖导向的回溯来有效地解决组合谜题，请考虑著名的 "多居所 "谜题：[29] Baker, Cooper, Fletcher, Miller和Smith住在一栋只有五层的公寓的不同楼层。贝克没有住在顶层。库珀没有住在底层。弗莱彻既不住在顶楼也不住在底楼。米勒住在比库珀高的楼层。
史密斯没有住在与弗莱彻家相邻的楼层。弗莱彻没有住在与库珀相邻的楼层。每个人都住在哪里？我们可以把这个问题设定为一个传播者问题。下面是这个问题的一个非常不复杂的表述。
(定义(多居所))
(让-细胞 (贝克-库珀-弗莱彻-米勒-史密斯)
(让((地板'(1 2 3 4 5)))
(p:amb baker floors) (p:amb cooper floors)
(p:amb fletcher floors) (p:amb miller floors)
(p:amb smith floors)
(require-distinct
(名单 贝克-库珀-弗莱彻-米勒-史密斯)
(let-cell ((b=5 #f)
 (c=1 #f)
 (f=5 #f)
(f=1 #f)
 (m>c #t)
 (sf #f)
(fc #f)
 (一个1)
 (五五)
S-F as-F F-C af-C)
(p:=5 baker b=5) ;Baker不在5上。
(p:=一个cooper c=1) ;Cooper不在1上。
(P:=5 Fletcher F=5) ;Fletcher不在5号位。
(p:=一个Fletcher f=1) ;Fletcher不在1上。
(p:>米勒-库珀m>c) ;米勒在库珀之上。
(c:+ Fletcher s-f smith) ;Fletcher and Smith
(c:abs s-f as-f) ; 不在
(p:=一个as-f sf)；相邻楼层。
(c:+ cooper f-c fletcher) ;Cooper and Fletcher
(c:abs f-c af-c); 不在。
(p:=一个af-c fc)；相邻楼层。
(名单 Baker Cooper Fletcher Miller Smith)))))
这就是说，贝克、库珀、弗莱彻、米勒和史密斯都选择住在五层楼中的一层，而且他们的选择必须是与众不同。
然后，我们看到他们选择的约束条件被表示为一个传播器电路。一些单元格，如b=5，被初始化为一个布尔值。因此，这条线路（p:=5 baker b=5）代表了贝克不住在五楼的约束条件。库珀和弗莱彻不住在相邻楼层的约束是通过将fc分配给#f和最后三个约束实现的。
为了使用传播者系统，我们需要定义所有的原始传播者，并对数据进行适当的分层。
(定义 (setup-propagator-system arithmetic)
(define layered-arith
(extend-arithmetic layered-extender arithmetic))
(Install-arithmetic! layered-arith)
(Install-core-propagators! merge-value-sets layered-arith layered-propagator-projector)
这个相当复杂的设置程序给出了建立和安装带有算术的传播器所需的信息，分层设置了可以跟踪的前提和可用于调试的原因。当传播器系统被加载时，默认的设置是针对数字数据的。
(setup-propagator-system numeric-arithmetic)
我们现在有能力运行我们的谜题范例。
(initialize-scheduler)
(定义答案(多居所))
(运行)
(map (lambda (cell)
(get-base-value (cell-strongest cell)))
答案)
;值。(3 2 4 5 1)
*number-of-calls-to-fail* ;值：106 我们看到了（正确的）结果：每个主人公住在哪一层。我们还看到，大约需要100次失败的赋值才能找到一个正确的赋值。15 事实证明，这个赋值是唯一的：没有其他赋值符合所给的约束条件。
请注意，无约束分配的总数是55=3125，但我们只用了大约100次试验就解决了这个问题。我们能够做到这一点是因为系统从错误中学习。对于每一次失败，它都会积累关于哪几组前提不能被同时相信的信息。正确地使用这些信息可以防止对那些鉴于以前的实验结果而无望的路径进行调查。
练习7.5：游艇名称谜题 使用传播者来计算并解决以下谜题。16 玛丽-安-摩尔的父亲有一艘游艇，他的四个朋友也都有。唐宁上校、霍尔先生、巴纳克-胡德爵士和博士。
帕克。这五个人中的每个人都有一个女儿，每个人都以其他人的一个女儿来命名他的游艇。巴纳克爵士的游艇是Gabrielle号，摩尔先生拥有Lorna号；Mr.
霍尔的罗莎琳德号。唐宁上校拥有的梅丽莎号，是以巴纳克爵士的女儿命名的。加布里埃尔的父亲拥有的游艇，是以帕克博士的女儿命名的。罗娜的父亲是谁？练习7.6：多住问题 对于第5.4章中的amb评价器来说，制定多住问题很容易。事实上，它比传播者系统更容易，因为我们可以用表达式的方式来思考和书写。
事实上，你将能够把弗莱彻和库珀没有住在相邻楼层这样的制约因素写成这样。
(要求 (not (= (abs (- fletcher cooper)) 1))
而不是
(C:+Cooper F-C Fletcher)
(c:abs f-c af-c)
(P:=一个AF-C FC)
其中，像f-c、af-c和fc这样的单元必须被声明，并且one和fc被初始化。这是因为传播系统是一个一般的布线图系统，而不是一个表达式系统。
a.使用第5.4节的amb评价器制定和解决多住户问题。用仪器检测系统以确定失败的次数。b. 编写一个小型编译器，将写成表达式的约束条件转换为传播者图的片段。你会发现这是很容易的。我们在第340页的练习7.1中对此进行了第一次尝试。但在这里，我们真正想做的是将第5.4节的代码翻译成传播者目标。证明你的编译得到了正确的答案。
c.需要多少次失败才能解决你编译成的传播者图的问题？如果需要200次以上的失败，你就编译成了非常糟糕的代码!练习7.7：重新审视纸牌游戏之谜 使用传播者重做练习5.17。
练习7.8：类型推理 在第4.4.2节中，我们建立了一个类型推理引擎作为统一匹配的应用实例。在这个练习中（这其实是一个实质性的项目），我们利用传播的优势实现了类型推理。
a.给定一个Scheme程序，构建一个传播网络，在每个对类型有用的位置都有一个单元。每一个这样的单元格都将是类型信息的仓库，这些信息将被积累到程序中该位置的类型信息上。构建连接这些单元的传播器，并施加程序结构所暗示的类型约束。
使用统一匹配作为单元格合并的操作。如果程序不能被打出来，统一可能会产生一个矛盾。
b.在程序中可能有一些单元，其类型没有受到相邻单元类型的充分约束。
然而，可以通过将一个一般类型的变量丢到这样的单元中，并允许该变量通过传播积累约束来刺激传播。这就是所谓的 "plunking"。试试吧。
c.在困难的情况下，类型推理可能需要进行猜测
(使用假设），并在发现矛盾时进行回溯。展示有必要这样做的案例。
d.对前提和原因的跟踪可以构建信息丰富的错误注释，但要做到这一点，你必须将每个程序位置与它的单元格联系起来，这样通过传播学到的东西就可以与被注释的程序联系起来。
你可以使用你喜欢的任何一种 "便条"，将基因座与单元格双向联系起来。在任何情况下，尽量做好解释工作，说明为什么某个基因座有确定的类型，或者为什么一个程序不能一致地打出来。
e.这种类型推理的实现是否实用？为什么或为什么不？如果不是，该如何改进？这个故事的寓意 解决组合难题很有趣，但这不是我们所做的事情的真正价值所在。的确，"SAT求解器 "对于解决这类现实世界的问题很重要。但是对于计算系统的设计，这里有一个更深层次的信息。通过把我们的编程从表达式结构概括为布线图（这可能是不方便的，但可以通过编译来缓解），我们已经有可能以一种自然而有效的方式把非确定性的选择顺利地整合到程序中。我们可以引入假设，它提供了由命题支持的替代值，这些命题可以毫无痛苦地被丢弃。这让我们有了正确对待一元二次方程等事物的自由。它们确实有两种解决方案，任何基于选择一种解决方案的计算都可能决定拒绝它，而另一种解决方案在经过长时间的计算后，可能导致一个可接受的结果。例如，鉴于p:sqrt计算的是一个实数的传统正平方根，我们可以建立一个定向传播器构造器p:honest-sqrt，其输入单元x∧2，输出单元x，给其用户一个（隐藏的）平方根的选择。
(定义-p:prop (p:honest-sqrt (x∧2) (x))
(let-cell (mul +x)
(p:amb mul '(-1 +1))
(p:sqrt x∧2 +x)
(p:* mul +x x))
这里重要的是，这种选择可以被引入，而不需要安排包围的机器知道如何处理这种模糊性。例如，将数字与它们的平方联系起来的约束传播器可以直接使用p:honest-sqrt。
(定义-c:道具 (c:方形 x x∧2)
(p:平方 x x∧2)
(p:honest-sqrt x∧2 x))
7.6 传播使退化 在任何重要系统的设计中，都会有许多针对每个组件的实施计划在每个细节层次上提出。然而，在最终交付的系统中，这种计划的多样性被丢失了，通常只有一个统一的计划被采纳和实施。就像在一个生态系统中，传统工程过程中多样性的丧失会带来严重的后果。
我们很少在程序中建立退化性，部分原因是它很昂贵，部分原因是我们传统上没有提供正式的机制来调解其使用。但是传播的想法提供了一个自然的机制来纳入退行性。在细胞中使用部分信息结构（由Radul和Sussman[99]引入）允许合并多个也许是重叠的信息源。我们在第7.1节的恒星距离例子中用区间来说明这一点。但是有很多方法可以合并部分信息：如第4.4.2节所示，部分指定的符号表达式可以用统一来合并。因此，部分指定信息的想法并不限于用传播者构建的系统，但是如果在传播者系统中这样做，就像第368页练习7.8中提出的那样，我们就有了一个结合多个独立机制的贡献的范式。
同样地，我们考虑了另一个来自人工智能问题解决领域的退化设计的想法：目标导向的调用。这个想法是，我们不是通过命名一个程序来指定 "如何 "完成一个目标，而是指定我们要完成 "什么"，并将能够完成该目标的程序与目标联系起来。这种联系通常是通过模式匹配来完成的，但这是偶然的，而不是必要的。17 如果有不止一种方法来完成目标，那么选择一个合适的程序就是一个选择点，可以注册回溯。
但是按时间顺序的回溯，受制于面向表达式语言的控制流，效率极低。我们必须跳出表达式评价结构，使依赖关系导向的回溯工作得很好，而传播是一种方法。我们仍然有一个潜在的指数级搜索，但是通过使用从经验中学习到的nogood集来消除许多不好的选择，大大减少了组合学。
当然，除了使用回溯搜索来选择一个特定的方式来完成一个目标外，还有其他的方式，目标可以调用退化的方法。例如，我们可能想并行地运行几种可能的方法来解决一个问题，选择首先终止的那一种。
假设我们有几个独立实施的程序，都是为了解决相同的（不精确指定的）一般问题类别。暂时假设每个设计都是合理的，并且对于实际操作中可能遇到的大多数问题都能正常工作。我们知道，我们可以通过将给定的程序组合成一个更大的系统，独立地调用每一个给定的程序并比较它们的结果，在每个问题上选择最佳答案，从而使系统更加稳健。如果这个组合有独立的方法来确定哪些答案是可以接受的，我们的情况就非常好。但是，即使我们沦为投票，我们也会得到一个能够可靠地覆盖更大的解决方案空间的系统。此外，如果这样的系统能够自动记录所有其中一个设计失败的情况，那么操作反馈就可以用来改进失败的程序的性能。
这种退化的设计策略可以在每个细节层面上使用。每个子系统的每个组件本身都可以是退化的设计。如果这些组件在子系统之间共享，我们就会得到一种可控的冗余，这种冗余是相当强大的。
然而，我们可以做得更好。我们可以提供一种机制，对独立设计的子系统的中间结果进行一致性检查，即使在一个子系统中没有特定的值与另一个子系统中的特定值完全对应。
举个简单的例子，假设我们有两个子系统，它们的目的是提供相同的结果，但计算的方式完全不同。假设设计者同意在其中一个设计的某个阶段，该设计中两个变量的乘积必须与另一个设计中两个变量的乘积相同。18 没有理由不在这个谓词所依赖的所有四个值可用时进行计算，从而在运行时提供一致性检查，并为设计者提供强大的调试信息。这可以用一个本地嵌入的约束网络来安排。
1 约束传播是由David Waltz在他关于线图解释的博士论文中提出的[125]。
Gerald Jay Sussman和Richard Stallman开发了基于约束传播的电路分析工具[119, 114]。
Eugene Freuder[39]将约束编程的想法转化为一项重要的智力工作，并有自己的期刊[24]。Guy Steele的博士论文[116]展示了如何构建一种基于约束的编程语言。
2 见[127]，第71页。
3 该值还有一个 "原因"，由以because开头的列表表示。在这种情况下，Vega-视差-距离单元中的值是由AU单元的内容除以c:视差<->距离的传播器中的t单元的内容而得出。方向划分传播器p:/是约束传播器c:*的一部分，它本身就是c:视差<->距离约束传播器的一部分。
这些理由可以变得非常冗长。当查询的结果没有帮助时，我们将省略 "因为 "的部分。通过递归地追寻这些理由，我们可以得到一个关于数值推导的非常冗长的解释。这些原因就是我们在第6.4.2节讨论的理由。
4我们在这里说谎!实际上Gatewood和de Jonge[43]的测量结果有些不同。他们测量的中心是130毫秒，而不是我们这里引用的131毫秒。
我们伪造了这一点，以便稍后能够说明一个计算上的问题。
5 事实上，Hipparcos的数据有一些问题。
具体来说，由Hipparcos测得的与一些非常明亮的星团的距离，如昴宿星团，显然与非常长的基线射电干涉仪的更好的测量结果不一致。但是这种差异并没有破坏其他的Hipparcos测量。
6这就是为什么我们伪造了盖特伍德和德容的测量结果。
如果我们正确引用的话，他们的结果不会与Hipparcos的结果重叠。事实上，Hipparcos的测量结果将完全包含在Gatewood和de Jonge的误差条中。
7这个公认的怪异系统来自于古希腊天文学家Hipparchus（约公元前190年-约公元前120年）的工作。
他给他目录中的每颗恒星分配了一个数字亮度。他把最亮的恒星称为1等，不太亮的称为2等，而最暗的称为6等。欧空局的Hipparcos空间天体测量任务（见第335页）就是为了纪念Hipparchus而命名的。
8 这是一种相当丑陋的语言，因为我们需要为一个表达式的所有中间部分命名和创建单元。
有很多方法可以使其变得漂亮，但如果我们从这种粗略但非常具体的布线图语言开始，概念就会更清晰。写一个小的编译器是很容易的，它可以把写成代数表达式的约束条件转换为传播者图的片段。(参见340页的练习7.1和367页的练习7.6）。
9这是阿列克谢-拉杜尔的博士论文[99，100]中的一个基本见解。
10 我们正在掩盖确定不确切的数量的等价性的严重问题。如果没有额外的局部信息，任何全局的等价概念都不能代表等价的标准。为了解决这个问题，我们可以为每个单元提供一个局部的等价谓词，并为精确的数量提供一个默认值。
11 在我们的实现中，有一个非常糟糕的想法。一个前提的信念状态的改变被实现为一个全局性的操作--这在一个平行过程的模拟中绝不是一个好主意！一个更好的实现是通过局部过程传播信念的改变，类似于它们支持的值被传播的方式。一个更好的实现是通过局部进程来传播信仰的改变，类似于它们所支持的值的传播方式。但是我们没有这样做--对不起！"。12 什么是最佳选择实际上是一个相当复杂的判断。
如果一个被支持的值比另一个更具体，例如一个更窄的区间，这就是一个更好的选择。另外，如果一个值在它的支持集合中比一个 "等价 "的值有更少的前提，那么它就更好，因为它需要更少的前提才能被相信。这是由合并价值集的机制实现的，我们将在第7.4.3节中描述。
13 依赖定向回溯是由Richard Stallman和Gerald Jay Sussman在电路分析的背景下首次提出的[114]。一个非常类似的技术，"句子学习"，是由Karl Lieberherr[84]在逻辑学的背景下开发的。条款学习现在被用于最好的SAT求解器中。Ramin Zabih、David McAllester和David Chapman展示了一种将这种技术纳入Lisp代码的方法[132]。Guy Steele展示了一种优雅的方法，将依赖关系导向的回溯纳入约束语言[116]。在Jon Doyle[30]和David McAllester[88]的工作基础上，Ken Forbus和Johan deKleer阐述了依赖关系和 "真值维护系统"[36]的理论和实践，这是思考依赖关系和回溯的一般方法。我们在本书中实现依赖关系导向的回溯的方式是由Alexey Radul和Gerald Jay Sussman[99, 100]开发的。
14 这种对组合程序的使用实现了逻辑的切割规则，它是模因的泛化。在命题逻辑中，切割规则被写成 (A ∨ B) ∧ (¬B ∨ C) ⊦ (A ∨ C)。这个规则与统一法（第4.4节）相结合，是Robinson [104]发明的著名的解析定理证明算法的基础。
15 失败的任务选择的精确数量非常依赖于计算的细节。在这个问题上，失败的选择数量可以从大约60到大约200不等，取决于传播者激活的顺序。但对于这个问题的表述，平均失败次数约为110次。
16 这个谜题取自一本名为Problematical Recreations的小册子，由Litton Industries在20世纪60年代出版，其中的内容是由堪萨斯州的工程师提供的。
17 Pattern-directed invocation是由Carl Hewitt在PLANNER[56]和Alain Colmerauer在Prolog[78]中引入的。这个想法已经扩散到许多其他系统和语言。
18 这实际上是一个真实的案例。在变分力学中，一个系统的拉格朗日和通过Legendre变换与之相关的哈密顿之和是广义动量1型和广义速度矢量的内积[121]。

