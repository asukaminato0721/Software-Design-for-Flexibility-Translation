自然和设计中的灵活性

很难设计出一种能很好地完成任何特定工作的通用机制，因此大多数工程系统都是为完成特定工作而设计的。通用的发明，如螺钉紧固件，是罕见的，具有重大意义。数字计算机是这种类型的突破，因为它是一种通用机器，可以模拟任何其他信息处理的机器。1 我们编写软件来配置我们的计算机，使其对我们需要完成的具体工作进行模拟。
作为过去工程实践的延伸，我们一直在设计软件以很好地完成特定工作。每一个软件都被设计为做一个相对狭窄的工作。随着要解决的问题的变化，软件也必须改变。但是，问题的小变化往往不会导致软件的小变化。
软件被设计得过于严密，没有太多的灵活性。因此，系统不能优雅地发展。它们很脆弱，必须在问题领域发生变化时用全新的设计来替代。
我们的工程系统不一定是脆性的。内部系统已经从一个小系统扩展到一个全球规模的系统。我们的城市在有机地发展，以适应新的商业模式、生活方式以及交通和通信手段。事实上，从对生物系统的观察中，我们看到有可能建立能够适应环境变化的系统，无论是单独的还是作为一个进化的组合。为什么这不是我们设计和构建大多数软件的方式呢？这有历史原因，但主要原因是我们不知道如何普遍地做到这一点。在这个时候，如果一个系统在面对需求的变化时被证明是健壮的，那是一个意外。


增量式编程
我们在本书中的目标是研究如何构建计算系统，使其能够轻松适应不断变化的需求。我们不应该去修改一个工作程序。我们应该能够对它进行补充，以实现新的功能，或者针对新的要求调整旧的功能。我们把这称为加法编程。我们探索在不破坏现有程序的情况下为其增加功能的技术。我们的技术并不保证增加的功能是正确的：增加的功能本身必须经过调试；但它们不应该意外地破坏现有的功能。
我们在本书中探讨的许多技术并不新颖：其中一些可以追溯到计算机的早期！它们也不是一套全面的技术。它们也不是一套全面的技术，而只是一些我们认为有用的技术。我们的目的不是要推广这些技术的使用，而是要鼓励一种注重灵活性的思维风格。
为了使加法编程成为可能，有必要尽量减少关于程序如何工作和如何使用的假设。在程序的设计和构建过程中所作的假设可能会减少程序未来可能的扩展。与其做这样的假设，不如建立我们的程序，根据程序运行的环境做出及时的决定。我们将探讨几种支持这种设计的技术。
我们总是可以将程序结合起来，以获得每个程序所支持的行为的结合。但我们希望整体不仅仅是其各部分的总和；我们希望组合系统的各部分能够合作，使系统具有任何一部分都无法单独提供的能力。但是，这里有一个权衡：我们组合成一个系统的各个部分必须有鲜明的独立关注。如果一个部件能很好地做一件事，那么它就更容易被重用，也比结合了几种不同能力的部件更容易调试。如果我们想进行增材制造，重要的是各个部件的结合要有最小的非预期的相互作用。
为了促进加法编程，我们有必要使我们制造的部件尽可能地简单和通用。例如，一个可以接受比手头问题严格所需的更广泛的输入的部件将比不接受的部件有更广泛的适用性。围绕标准化接口规范建立起来的零件系列可以混合和匹配，从而形成各种各样的系统。重要的是要为我们的部件选择正确的抽象层次，通过确定系列的话语领域，然后为该领域构建系列。我们在第二章开始考虑这些要求。
为了获得最大的灵活性，一个部件的输出范围应该相当小，而且定义明确--比任何可能接受该输出的部件的可接受输入范围小得多。这类似于我们在计算机系统入门科目中教给学生的数字抽象中的静态学科[126]。
数字抽象的本质是，输出总是比下一阶段的可接受的输入要好，这样就可以抑制噪声的产生。
在软件工程中，这一原则被奉为 "Postel法"，以纪念互联网先驱Jon Postel。在描述互联网协议的RFC760[97]中，他写道："一个协议的实现必须是稳健的。每个实现都必须期望与不同的人创建的其他实现相互操作。虽然本规范的目标是明确协议，但也有可能出现不同的解释。一般来说，一个实现在其发送行为中应该是保守的，而在其接收行为中应该是自由的"。这通常被总结为 "在你所做的事情上是保守的，在你接受别人的事情上是自由的。"使用比看起来必要的更一般的部分，在我们系统的整个结构中建立一定程度的灵活性。对需求的微小扰动是可以容忍的，因为每个部件都是为了接受扰动（噪音）的输入。
一个用于特定话语领域的混合匹配部件系列是特定领域语言的基础。攻克一系列难题的最好方法是创造一种语言--一套基元、组合手段和抽象手段--使这些问题的解决方案易于表达。因此，我们希望能够根据需要建立适当的特定领域语言，并灵活地组合这些语言。Westart在第2章中对特定领域语言进行了思考。更有力的是，我们可以通过直接评估来实现这种语言。
我们将在第5章中对这个想法进行扩展。
提高灵活性的一个策略是泛型调度，这对许多程序员来说应该很熟悉。我们将在第3章中广泛地探讨这个问题。泛型调度通常是一种有用的方法，它可以根据传递给程序的参数的细节，增加额外的处理程序（方法）来扩展程序的适用性。通过要求处理程序对不相干的参数集作出反应，我们可以避免在添加新的处理程序时破坏现有的程序。然而，与典型的面向对象编程环境中的泛型调度不同，我们的泛型调度并不涉及类、实例和继承等概念。这些想法通过引入虚假的本体承诺而削弱了关注点的分离。
第6章将探讨的一个完全不同的策略是将数据和程序分层。这利用了数据通常有相关元数据的想法，这些元数据可以与数据一起被处理。
例如，数字数据通常有相关的单位。我们将展示如何在事后提供添加层的灵活性，以增强程序的新功能，而无需对原始程序进行任何修改。
我们还可以建立一个系统，将部分信息的多个来源结合起来以获得更完整的答案。当这些贡献来自于独立的信息来源时，这是最有力的。在第四章中，我们将看到类型推理实际上是结合多个部分信息源的问题。关于一个值的类型的局部诱导线索，例如，一个数字比较需要数字输入并产生一个布尔输出，可以与其他局部类型约束结合起来，产生非局部类型约束。
在第七章，我们将看到一种不同的方式来结合部分信息。与附近恒星的距离可以通过视差来估计，即测量地球围绕太阳旋转时星象在背景天空中移动的角度。与恒星的距离也可以通过考虑其亮度和光谱来估计，利用我们对恒星结构和演化的理解。这些估计可以结合起来，得到比单个贡献更准确的估计。
一个双重的想法是使用退行性：有多种计算方法，可以根据需要进行组合或调制。退行性有许多有价值的用途，包括错误检测、性能管理和入侵检测。
重要的是，退行性也是加法的：每个贡献的部分都是自成一体的，可以自己产生一个结果。退化的一个有趣的用途是根据上下文动态地选择一个算法的不同实施方案。这就避免了对实现方式进行假设的需要。
灵活性的设计和构建有明确的成本。一个可以接受比解决当前问题所需的更多种类的输入的程序会有比绝对必要的更多的代码，并且会让程序员花费比绝对必要的更多的思考。通用调度、分层和退化也是如此，每一种都涉及内存空间、计算时间和/或程序员时间的持续开销。但是，软件的主要成本是程序员在产品生命周期内花费的时间，包括维护和适应不断变化的需求。尽量减少重写和重构的设计将总体成本降低到增量而不是完全重写。换句话说，长期成本是加法的，而不是乘法的。

1.1 计算的结构
建筑学中的一个比喻可能会对我们所考虑的系统的类型有所启发。在了解了要建造的场地的性质和对要建造的结构的要求之后，设计过程从一个参数开始：一个设计的组织原则。参数通常是各部分的几何排列的草图。参数也可以体现抽象的想法，比如像路易斯-伊萨多-卡恩的作品中那样，划分为 "服务空间 "和 "仆人空间"[130]。这种分解的目的是将建筑问题分成若干部分，将基础设施的支持，如走廊、洗手间、机械室和电梯，与需要支持的空间，如学术建筑中的实验室、教室和办公室分离出来。
该部分是一个模型，但它通常不是一个完全可行的结构。它必须用功能元素进行阐述。如何安装楼梯和电梯？暖通空调管道、管道、电力和通信分配系统在哪里？我们将如何运行一条道路以适应服务车辆的交付模式？这些阐述可能会引起对参数的修改，但参数仍然是一个支架，这些阐述是围绕这个支架展开的。
在编程中，参数是将要进行的计算的抽象计划。在小范围内，参数可能是一个抽象的算法和数据结构描述。在更大的系统中，它是一个抽象的计算阶段和平行分支的组成。在更大的系统中，它是对逻辑（甚至是物理）区域的能力分配。
传统上，程序员并不能作为架构师来设计。在非常精细的语言中，比如Java，部分内容与精细的内容紧密地混合在一起。服务空间"，即实际描述所需行为的表达式，与 "服务空间"，如类型声明、类声明以及库的导入和导出，严重地膨胀了。4 更加稀疏的语言，如Lisp或Python，几乎没有给仆人空间留下任何空间，而且试图增加声明，甚至是咨询性的声明，都被避开了，因为它们阻碍了暴露的参数的美观。
架构部分应该足够完整，以允许创建可用于分析和批评的模型。
一个程序的骨架计划应该足以用于分析和批评，但它也应该是可执行的，用于实验和调试。就像建筑师必须填写部分内容以实现所设计的结构一样，程序员必须详细制定计划以实现所需的计算系统。分层(第6章介绍)是建立允许这种阐述的系统的一种方式。


1.2 实现灵活性的智能部件
大型系统是由许多较小的组件组成的，每个组件都对整体的功能有所贡献，要么直接提供该功能的一部分，要么与其他组件合作，以系统架构师指定的某种模式相互连接以建立所需的功能。系统工程中的一个核心问题是建立接口，允许组件之间的相互连接，以便这些组件的功能可以被组合起来，形成复合功能。
对于相对简单的系统，系统架构师可以为各种接口制定正式的规范，这些接口必须由要相互连接的组件的实现者来满足。事实上，电子学的惊人成功是基于这样一个事实：制定这样的规范并满足它们是可行的。高频模拟设备是通过具有标准化阻抗特性的同轴电缆和标准化的连接器系列进行互连的[4]。一个元件的功能和它的接口行为通常只需要几个参数就可以指定[60]。在数字系统中，事情就更清楚了：有信号含义的静态规范（数字抽象）；有信号时间的动态规范[126]；有元件外形的机械规范。5 不幸的是，随着系统复杂性的增加，这种先验的规范会逐渐变得更加困难。我们可以规定一个下棋的程序是合法的--它不会作弊--但是我们如何开始规定它下了一盘好棋？我们的软件系统是由大量定制的高度专业化的部件组成的。
指定软件组件的困难由于组件的个性化性质而加剧了。
相比之下，生物学构建的系统具有巨大的复杂性，却没有非常大的规格（考虑到要解决的问题！）。我们身体里的每一个细胞都是一个子代的后代。
所有的细胞都有完全相同的遗传禀赋（大约1GB的ROM！）。然而，有皮肤细胞、神经元、肌肉细胞，等等。这些细胞自己组织起来，成为独立的组织、器官和器官系统。事实上，这1GB字节的ROM规定了如何从大量容易发生故障的部件中建立极其复杂的机器（人类）。它规定了如何操作这些基本部件以及如何配置它们。它还规定了如何在各种恶劣的条件下可靠地操作这台复合机器，使其具有很长的使用寿命，以及如何保护这台机器不被其他喜欢吃的人吃掉 如果我们的软件组件更简单或更通用，它们就会有更简单的规格。如果组件能够自己适应周围的环境，其规格的精确性就不那么重要了。生物系统利用这两种策略来建立强大的复杂生物体。不同的是，生物细胞是动态可配置的，并且能够使自己适应其环境。这是可能的，因为细胞的分化和专业化的方式取决于它的环境。我们的软件通常没有这种能力，因此，我们必须用手来调整每个部分。生物学怎么可能工作？考虑一下另一个例子。我们知道，大脑的各个部分是由巨大的神经元束连接在一起的，而基因组中没有足够的信息来详细说明这种相互连接。大脑的各个部分很可能会根据它们共享重要经验的事实，学会相互交流。6 因此，界面必须是自我配置的，基于一些一致性规则、来自环境的信息和广泛的探索行为。这在启动时间上是相当昂贵的（配置一个工作的人类需要几年的时间），但是它提供了一种迄今为止在我们的工程实体中没有发现的稳健性。
一个想法是，生物系统使用的背景信号是信息性的，而不是强制性的。7 没有一个总指挥说每个部分必须做什么；相反，各部分根据其周围环境选择自己的角色。细胞的行为不在信号中编码；它们在基因组中单独表达。
信号的组合只是启用了一些行为，而禁用了其他行为。这种弱联系允许在不修改定义区域的机制的情况下，实现在不同区域启用的行为的变化。因此，以这种方式组织的系统是可进化的，因为它们可以适应某些区域的适应性变化而不改变其他区域的子系统的行为。
传统上，软件系统是围绕着命令式模型建立的，在这个模型中，有一个控制的层次结构。各个部分被认为是哑巴演员，做他们被告知的事情。这使得适应非常困难，因为所有的变化都必须反映在整个控制结构中。在社会系统中，我们很清楚严格的权力结构和集中指挥的问题。但我们的软件却遵循这种有缺陷的模式。我们可以做得更好：让各部分更聪明，各自负责，可以简化适应，因为只有那些直接受变化影响的部分需要回应。


身体计划
所有的脊椎动物都有基本相同的身体结构，然而细节上的差异是巨大的。事实上，所有具有双侧对称性的动物都有共同的homeobox基因，如Hox复合体。这种基因在发育中的动物体内产生一个近似的坐标系统，将发育中的动物分成不同的区域。这些区域为细胞的分化提供了背景。9 甚至构造方法也是共同的--导管腺和器官（如肺和肾）的形态发生是基于一个胚胎学技巧：上皮细胞自动侵入间质10，产生一个由分化的间质包围的盲端管的分支迷宫。考虑一下无线电接收器的设计。已经发现了几个大的 "体例"，如直接转换、TRF（调谐无线电频率）和超外差。
每一种都有一连串的位置，由相当于Hox复合体的工程定义，从天线到输出换能器的系统模式。例如，一个超外差接收机（图1.1）有一套标准的定位（从头到尾）。
图1.1 由埃德温-阿姆斯特朗少校在1918年发明的超外差计划，仍然是无线电接收机的主流 "体例"。
在这个计划中，每个模块都分解成其他模块，如振荡器、混频器、滤波器和放大器，等等，一直到各个电子元件。
此外，每个模块可以以许多可能的方式进行实例化：射频部分可能只是一个滤波器，也可能是一个精心设计的滤波器和放大器组合。事实上，在一个模拟电视接收器中，混频器的部分输出被视频链处理为AM，另一部分被处理为FM以产生音频。而有些部分，如转换器，可能会被递归地阐述（就像Hox复合体的部分被复制一样！）以获得多转换的接收器。
在生物系统中，这种隔间结构在更高的组织层次上也得到支持。有一些组织专门成为区室的边界，并有管子将它们相互连接。器官被这种组织所包围，并由这种管子相互连接，整个结构被包装成适合于腔体，腔体是高等生物体内衬有专门组织的腔体。
类似的技术也可以用在软件中。一个身体计划只是一个包装器，它结合了部分指定的组件。这是一种组合器：一种将子部分组合在一起成为一个更大的部分的东西。有可能创建组合器语言，其中的组件和复合体都有相同的接口规范。在组合器语言中，有可能从少量混合匹配的组件中建立任意大的组合。自相似的结构使组合变得容易。在第2章中，我们将开始构建基于组合器的软件，这个主题将贯穿本书的所有其他部分。
类似的事情也可以用特定领域的语言来完成。
通过对领域进行抽象，我们可以在不同的领域使用相同的独立于领域的代码。例如，数字积分器在任何有数字方面的领域都是有用的，不管是什么领域。另一个例子是第四章的模式匹配，它可以应用于各种领域。
生物机制是通用的，因为每个组件原则上都可以作为任何其他组件。模拟电子元件在这个意义上不是通用的。它们不会根据局部信号使自己适应周围环境。但有一些通用的电子构件（例如，带有模拟接口的可编程计算机！）12。对于低频应用，人们可以用这些构件建立模拟系统。如果每个积木都有成为系统中任何积木所需的所有代码，但通过与相邻积木的相互作用而变得专门化，而且如果包中有额外的非专门化的 "干细胞"，那么我们可以想象建立自我重新配置和自我修复的模拟系统。但现在我们仍然单独设计和建造这些部件。
在编程中，我们确实有一个通用元素的想法：评估器。评估器接受对一些要进行的计算的描述和对该计算的输入。它产生的输出，如果我们把输入传递给一个实现所需计算的定制组件，就会产生。在计算中，我们有机会追求胚胎发展的强大的灵活策略。我们将在第五章详细阐述评价器技术的使用。


1.3 冗余和退化 生物系统已经进化出大量的稳健性。生物系统的一个特点是它们是冗余的。
像肝脏和肾脏这样的器官是高度冗余的：它们的能力远远超过完成工作所需的能力，所以一个人缺少一个肾脏或部分肝脏并没有明显的丧失能力。
生物系统也是高度退化的：通常有许多方法来满足一个给定的要求。13 例如，如果一个手指受损，其他手指可以被配置为拾起一个物体的方法。我们可以从各种来源获得生命所需的能量：我们可以代谢碳水化合物、脂肪和蛋白质，尽管消化和从这些来源中提取能量的机制非常不同。
遗传密码本身是退化的，因为从密码子（核苷酸的三倍）到氨基酸的映射不是一对一的：有64个可能的密码子只指定大约20种可能的氨基酸[86, 54]。因此，许多点突变（单个核苷酸的变化）并不改变编码区所指定的蛋白质。另外，很多时候，一个氨基酸被一个类似的氨基酸取代并不损害蛋白质的生物活性。
这些退化提供了变异积累的方式，而没有明显的表型后果。此外，如果一个基因被复制了（这并不是一种罕见的情况），拷贝可能会悄悄地发生分歧，允许发展出将来可能成为有价值的变体，而不干扰目前的生存能力。此外，这些拷贝可以被置于不同的转录控制之下。
退行性是进化的产物，它当然能使进化成为可能。可能退行性本身就是被选择的，因为只有那些有大量退行性的生物才有足够的适应性，以便在环境变化时能够生存。14 例如，假设我们有一些生物（或工程系统）是退行性的，因为有几个非常不同的独立机制来实现一些基本功能。如果环境发生变化（或要求发生变化），以至于其中一种实现基本功能的方式变得不可行，该生物将继续生存和繁殖（该系统将继续满足其规格）。但是，已经无法运行的子系统现在可以进行突变（或修复），而不影响整个系统的生存能力（或当前的运行）。
物理学的理论结构是深度退化的。例如，经典力学的问题可以用多种方式来处理。有牛顿式的矢量力学表述，也有拉格朗日式和哈密尔顿式的变分力学表述。如果矢量力学和变分力学的任何一种形式都适用，它们会产生等价的运动方程。对于分析具有耗散力（如摩擦力）的系统，矢量力学是有效的；变分方法不大适合这种系统。拉格朗日力学在处理具有刚性约束的系统时远比矢量力学好，而哈密尔顿力学提供了典范变换的力量，有助于利用相空间的结构来理解系统。拉格朗日和哈密尔顿公式都有助于我们深入了解对称性和守恒量的作用。有三种重叠的方法来描述一个机械系统，当它们都适用时就会达成一致，这一事实给了我们对任何问题的多种攻击途径[121]。
在故障成本极高的关键系统中，工程系统可能包含一些冗余。但它们几乎从未有意纳入生物系统中的那种退化现象，除非是作为非最优设计的副作用。15 退化现象可以为我们的系统增加价值：就像冗余一样，我们可以交叉检查退化计算的答案以提高鲁棒性。但退化的计算不仅是冗余的，而且是彼此不同的，这意味着一个计算中的错误不太可能影响其他计算。这不仅对可靠性来说是一个积极的特征，对安全性来说也是如此，因为一个成功的攻击必须破坏多个退化的部分。
当退化的部分产生部分信息时，它们组合的结果可能比任何单独的结果更好。一些导航系统利用这个想法，将几个位置估计结合起来，产生一个高度准确的结果。我们将在第七章中探讨结合部分信息的想法。


1.4 探索性行为 生物系统中最强大的鲁棒性机制之一是探索性行为。16 其思想是，期望的结果是由一个生成和测试机制产生的（见图1.2）。这种组织方式使生成机制具有普遍性，并独立于接受或拒绝特定生成结果的测试机制。
图1.2 探索性行为可以通过两种方式完成。一种方式是生成器提出一个动作（或结果），这可能被测试者明确拒绝。然后，生成器必须提出一个替代方案。另一种方式是生成器产生所有的替代方案，没有反馈，由一个过滤器选择一个或多个可接受的方案。
例如，支持细胞形状的刚性骨架的一个重要组成部分是一个微管阵列。每个微管是由蛋白质单元组成的，它们聚集在一起形成微管。
微管在活细胞中不断地被创造和破坏；它们被创造出来，向各个方向生长。然而，只有遇到细胞膜上的激振杆或其他稳定器的微管才是稳定的，从而支持由稳定器的位置决定的形状[71]。所以生长和维持形状的机制相对独立于指定形状的机制。这种机制部分地决定了复杂生物体中许多类型的细胞的形状，它在动物中几乎是普遍的。
探索行为出现在生物系统的各个细节层面。一个成长中的胚胎的神经系统产生的神经元数量远远大于在成人中持续存在的数量。那些在其他神经元、感觉器官或肌肉中找到适当目标的神经元将存活下来，而那些没有找到目标的神经元则会自杀。手是通过产生垫子和通过凋亡（程序性细胞死亡）删除手指之间的材料而形成的[131]。我们的骨骼不断地被造骨细胞（建造骨骼）和破骨细胞（破坏骨骼）重塑。骨骼的形状和大小是由其环境决定的约束条件决定的：它们必须与之相关的部分，如肌肉、韧带、肌腱和其他骨骼。
因为生成器不需要知道测试者如何接受或拒绝其提议，而测试者也不需要知道生成器如何提出其提议，所以这两个部分可以独立发展。这使得适应和进化更加有效，因为对这两个子系统中的一个或另一个的突变不需要伴随着对另一个的补充突变。然而，这种隔离可能是昂贵的，因为产生和拒绝失败的建议的努力被浪费了。生物变异的机制是随机变异：对遗传指令的修改。大多数突变是中性的，因为它们不会因为系统中的退行性而直接影响健康。自然选择是测试阶段。它不依赖于变异的方法，而变异的方法也不会预见到选择的效果。
甚至还有更惊人的现象：即使在密切相关的生物中，一些在成体中最终几乎相同的部件在胚胎中是由完全不同的机制构建的。18 对于遥远的关系，构建共同结构的不同机制可以归结为 "趋同进化"，但对于近亲来说，这更可能是细节层次分离的证据，其中结果的规定在某种程度上与完成的方式无关。
工程化的系统可能显示出类似的结构。我们试图将规范与实现分开：通常有多种方式来满足一个规范，而设计可能会选择不同的实现方式。用来对数据集进行排序的最佳方法取决于数据集的预期大小，以及比较元素的计算成本。多项式的适当表示取决于它是稀疏的还是密集的。但是，如果像这样的选择是动态做出的（一个不寻常的系统），它们是确定的：我们没有看到很多系统同时尝试几种方式来解决一个问题，并使用首先收敛的方式（所有这些核心到底是用来干什么的？） 甚至很少有系统按顺序尝试多种方法：如果一种方法失败，就尝试另一种。我们将在第四章中研究使用回溯来实现模式匹配的生成和测试机制。我们将在第五章中学习如何在语言中建立自动回溯机制。在第七章中，我们将学习如何建立一个依赖性导向的回溯机制，从失败中提取尽可能多的信息。


1.5 灵活性的代价
Lisp程序员知道一切的价值，但也知道什么的代价。
Alan Perlis转述Oscar Wilde的话 我们已经注意到，在使用泛型、层、冗余、退化和探索性行为的系统中，通用性和可进化性得到了加强。如果孤立地看，其中每一项都很昂贵。一个在广泛的输入范围内工作的机制必须比一个专门针对特定输入的机制做得更多才能得到同样的结果。冗余机制比同等的非冗余机制有更多的部件。一个退化的机制甚至显得更加奢侈。通过生成和测试方法进行探索的机制很容易陷入不可行的指数搜索。然而，这些都是可进化系统的关键因素。也许为了制造真正强大的系统，我们必须愿意为这些看起来相当复杂和昂贵的基础设施付费。
问题的一部分是我们在错误地思考成本问题。时间和空间的使用很重要，但我们对这些成本的来源的直觉却很差。每个工程师都知道，评估一个系统的真正性能需要广泛而仔细的测量，这往往表明成本在令人惊讶的地方。随着复杂性的增加，这只会越来越难。但我们坚持在程序的各个层面上做过早的优化，而不知道其真正的价值。
假设我们把系统中必须快速的部分和必须智能的部分分开。在这种政策下，通用性和可进化性的成本可以限制在必须是智能的部分。这在计算系统中是一个不寻常的观点，然而它在我们的生活经验中却无处不在。当我们试图学习一项新的技能时，比如弹奏乐器，最初的阶段涉及到有意识的活动，将预期的效果与产生它所需的物理动作联系起来。但随着技能的掌握，大部分的工作都是在无意识的情况下完成的。
这对于能够快速演奏是至关重要的，因为有意识的活动太慢了。
在硬件和软件之间的区别中也有类似的论点。硬件的设计是为了提高效率，其代价是有一个固定的界面。然后，人们可以在该界面之上建立软件--实际上是用软件创造一个虚拟机器。这个额外的抽象层产生了一个众所周知的成本，但这种折衷是非常值得获得的通用性的。(否则我们还在用汇编语言编程！)这里的重点是，这种分层结构提供了一种同时拥有效率和灵活性的方法。我们相信，要求整个系统以最有效的方式来实现是适得其反的，它阻碍了适应未来需求的灵活性。一个系统的真正成本是程序员花费的时间--在设计、理解、维护、修改和调试系统方面。因此，增强适应性的价值可能更加极端。一个容易适应和维护的系统消除了一个最大的成本：教新的程序员现有的系统是如何工作的，所有的血淋淋的细节，这样他们就知道该从哪里下手修改代码。事实上，我们脆弱的基础设施的成本可能大大超过了灵活设计的成本，包括灾难的成本和由于重新设计和重建的时间而损失的机会成本。如果为了一个新的需求而重新编程系统所花费的时间中，有很大一部分是由该系统自己适应新的情况而取代的，这可能是一个更大的胜利。

正确性的问题 对于乐观主义者来说，杯子是半满的。对悲观主义者来说，杯子是半空的。对工程师来说，玻璃杯是它需要的两倍大。
作者：未知 但以一种使系统的适用范围大于我们在设计时考虑的一系列情况的方式来构建系统，可能会有更大的代价。因为我们打算愿意将我们的系统应用于它们并非为之设计的环境中，所以我们不能确定它们是否能正常工作 在计算机科学中，我们被教导说，软件的 "正确性 "是最重要的，而正确性是通过建立组件和组件系统的正式规范来实现的，并通过证明组件组合的规范是由组件的规范和它们的组合模式来满足的19 我们断言，这种纪律使系统更加脆弱。事实上，为了制造真正健壮的系统，我们必须摒弃这种严格的纪律。
要求证明的问题是，证明一般机制的一般属性通常比证明在受限情况下使用的特殊机制的特殊属性要难。这鼓励我们使我们的部分和组合尽可能地特殊化，以便我们可以简化我们的证明。
但是，严格专业化的部分的组合是很脆的--没有变化的余地！20 我们并不是在反对证明。如果有的话，它们是非常好的。21 然而，即使对于安全关键型系统，如自动驾驶仪，将适用性限制在系统被证明为正确的情况下，实际上可能导致不必要的失败。事实上，我们希望自动驾驶仪能够善意地尝试安全地驾驶一架飞机，而飞机的损坏方式是设计者所没有预料到的！我们反对的是对系统的约束。我们反对要求证明的纪律：要求所有的东西在被允许用于某种情况之前都必须被证明是适用的，这过度地抑制了可以提高设计的稳健性的技术的使用。尤其是那些允许一种方法在其已被证明的领域之外被严格使用的技术，以及那些为未来的扩展提供条件而不对事物的扩展方式加以限制的技术。
不幸的是，我们提倡的许多技术使证明问题变得更加困难，甚至实际上不可能。
另一方面，有时攻击一个问题的最好方法是将其泛化，直到证明变得简单。

---

1 阿兰-图灵[124]发现万能机的存在，以及图灵机可以计算的函数集与阿伦佐-丘奇的λ微积分[17，18，16]中可表示的函数集以及库尔特-哥德尔[45]和雅克-赫布兰德[55]的一般递归函数等价的事实，属于二十世纪最伟大的智力成就。
2当然，也有一些精彩的例外。例如，Emacs[113]是一个可扩展的编辑器，它一直在优雅地进化，以适应计算环境的变化和用户期望的变化。计算世界刚刚开始探索 "工程框架"，例如，微软的.net和Sun的Java。这些都是为了成为支持可进化系统的基础设施。
3A parti（发音为parTEE）是一个建筑作品的中心思想：它是"[建筑]构成被设想为一个整体，细节在以后被填入"。[62] 4Java确实支持接口，这可以被认为是一种parti，因为它们是程序的抽象表示。但是parti结合了抽象和具体的组件，而Java接口则是完全抽象的。更不用说过度使用接口被许多程序员认为是一种 "代码气味"。
5 《TTL设计工程师数据手册》[123]是一套成功的数字系统组件规范的典型例子。TTL规定了几个内部一致的小型和中型集成电路元件的 "系列"。这些系列在速度和功率耗散等特性上有所不同，但在功能上没有区别。该规范描述了每个系列的静态和动态特性、每个系列的可用功能，以及元件的物理封装。这些系列是交叉一致的，也是内部一致的，因为每个系列中的每个功能都是可用的，具有相同的包装和一致的描述术语。因此，设计者可以设计一个复合功能，然后再选择系列来实现。每个优秀的工程师（和生物学家！）都应该熟悉TTL的教训。
6 Jacob Beal在他的硕士论文[9]中已经证明了这种自我配置行为的基本版本。
7 Kirschner和Gerhart对此进行了研究[70]。
8 这是对涉及形态物质梯度的复杂过程的一个非常模糊的描述。我们不打算在这里得到更精确的描述，因为这不是关于生物学，而是关于生物学如何为工程学提供信息。
9我们已经在我们的无定形计算项目[2]中调查了这种开发所涉及的一些编程问题。
10 自动地。"自动地，但由于某种原因（通常是因为它太复杂，或太丑陋，甚至可能太微不足道），说话者不愿意解释。" 摘自《黑客词典》[117, 101] 11 这种机制的一个经过充分研究的例子是老鼠颌下腺的形成。例如，见[11]中的处理方法或[7]中3.4.3节的总结。
12 Piotr Mitros开发了一种新的设计策略，从潜在的通用构件中构建模拟电路。见[92]。
13 尽管在极端情况下很清楚，但生物学家对冗余和退化的区分在边界上是模糊的。
更多信息见[32]。
14 一些计算机科学家利用模拟来研究可进化性的演变[3]。
15 事实上，人们经常听到反对在工程系统中建立退行性的论点。例如，在计算机语言Python的哲学中，有人声称 "应该有一种，最好是只有一种明显的方法来做。" [95] 16 Kirschner和Gerhart[70]的书中很好地探讨了这个论点。
17 如果有足够的信息存在，可以迅速减少必须测试的候选者数量，那么这种花费就可以大大减少。我们将在第七章中研究这种优化的一个非常好的例子。
18 小鸡的角膜和小鼠的角膜几乎完全一样，但这两者的形态发生却完全不一样：形态发生的顺序甚至不一样。巴德[7]第3.6.1节报告说，在不同的物种中有不同的方法来形成相同的结构是很常见的。他引用了一些例子。一个壮观的例子是，青蛙Gastrotheca riobambae（见del Pino和Elinson[28]）从一个胚胎盘发育出普通青蛙的形态，而其他青蛙则从一个近似球形的胚胎发育。
19 要指定一个复杂的系统是很难的，也许是不可能的。
正如第7页所指出的，规定一个棋手必须下合法的棋是很容易的，但我们如何规定它下得好呢？而且，与国际象棋不同的是，国际象棋的规则不会改变，大多数系统的规格会随着使用条件的改变而动态变化。在快速变化的税法下，我们如何规定一个会计系统？20 事实上，波斯特尔定律（在第3页）直接反对从精确和狭义的部分建立系统的做法。波斯特尔定律指示我们使每个部分的普遍适用性超过对任何特定应用的绝对需要。
21 像垃圾收集器这样的原始存储管理子系统中的一个微妙的错误，是非常难以调试的--尤其是在一个有并发进程的系统中！但是，如果我们保留这样的子系统，那么我们就会发现，这些子系统中的错误是非常多的。但是，如果我们保持这样的子系统简单而小，它们可以被指定，甚至可以用可操作的工作量来证明 "正确"。
